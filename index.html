<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jaroet Outliner</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
      }
    </script>
    
    <style>
      :root {
        --main-color: #60a5fa;
        --font-family: sans-serif;
        --font-size: 16px;
      }
      body {
        font-family: var(--font-family);
        font-size: var(--font-size);
        overflow: hidden; /* Prevent body scroll when resizing */
      }
      /* Simple scrollbar styling for a more modern look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      /* Light theme */
      ::-webkit-scrollbar-track {
        background: #f1f5f9; /* cool-gray-100 */
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; /* cool-gray-300 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; /* cool-gray-400 */
      }
      /* Dark theme */
      .dark ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
      .focus-outline {
        outline: 2px solid var(--main-color);
        outline-offset: -1px;
        border-radius: 4px;
      }
      .selected-item-bg {
        /* Mix with 20% black to darken the main color, ensuring good contrast with white text */
        background-color: color-mix(in srgb, var(--main-color) 80%, black);
      }
      .tag-span {
        background-color: color-mix(in srgb, var(--main-color) 20%, transparent);
        color: color-mix(in srgb, var(--main-color) 70%, black);
        border-radius: 0.375rem; /* rounded-md */
        padding: 0.125rem 0.25rem; /* py-0.5 px-1 */
        margin: 0 0.0625rem; /* mx-px */
        font-size: 0.875rem; /* text-sm */
      }

      .dark .tag-span {
        color: var(--main-color);
      }
    </style>
    
    <!-- React UMD builds (globals) -->
    <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js"></script>

    <!-- Other dependencies (globals) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/dexie@4.0.7/dist/dexie.js"></script>
    
    <!-- Babel Config -->
    <script>
      Babel.config({
        presets: ["env", "react", "typescript"]
      });
    </script>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0"
  }
}
</script>
</head>
  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 antialiased transition-colors duration-200">
    <div id="root"></div>
    <!-- Application Code -->
    <script type="text/babel">
      // --- START: types.ts ---
      interface Bullet {
        id: string;
        text: string;
        children: Bullet[];
        isCollapsed: boolean;
        isReadOnly?: boolean;
        originalId?: string;
        createdAt?: number;
        updatedAt?: number;
      }

      interface FlatBullet {
        id: string;
        text: string;
        path: string[];
        createdAt?: number;
        updatedAt?: number;
      }

      interface Settings {
        mainColor: string;
        fileName: string;
        fontFamily: string;
        fontSize: number;
      }

      type CoreBullet = {
        id: string;
        text: string;
        children: CoreBullet[];
        originalId?: string;
        createdAt?: number;
        updatedAt?: number;
      };
      // --- END: types.ts ---


      // --- START: components/Icons.tsx ---
      const ChevronRightIcon = ({ className = 'w-4 h-4' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
        </svg>
      );

      const ChevronDownIcon = ({ className = 'w-4 h-4' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
        </svg>
      );

      const CircleIcon = ({ className = 'w-2 h-2', color = 'var(--main-color)' }) => (
        <svg viewBox="0 0 100 100" className={className}>
          <circle cx="50" cy="50" r="50" fill={color} />
        </svg>
      );

      const SearchIcon = ({ className = 'w-5 h-5' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
        </svg>
      );

      const UploadIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
          </svg>
      );

      const DownloadIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
      );

      const HomeIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
            <path d="M11.47 3.84a.75.75 0 011.06 0l8.69 8.69a.75.75 0 101.06-1.06l-8.689-8.69a2.25 2.25 0 00-3.182 0l-8.69 8.69a.75.75 0 001.061 1.06l8.69-8.69z" />
            <path d="M12 5.432L4.432 13v6.75a2.25 2.25 0 002.25 2.25h10.636a2.25 2.25 0 002.25-2.25v-6.75L12 5.432z" />
          </svg>
      );

      const AppointmentIcon = ({ className = 'w-4 h-4' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18" />
          </svg>
      );

      const SettingsIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.242 1.41l-1.028.937c-.28.254-.434.62-.434.995s.154.74.434.995l1.028.937a1.125 1.125 0 01.242 1.41l-1.296 2.247a1.125 1.125 0 01-1.37.49l-1.217-.456c-.355-.133-.75-.072-1.075.124a6.57 6.57 0 01-.22.127c-.331.183-.581.495-.645.87l-.213 1.281c-.09.543-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.313-.686-.645-.87a6.52 6.52 0 01-.22-.127c-.324-.196-.72-.257-1.075-.124l-1.217.456a1.125 1.125 0 01-1.37-.49l-1.296-2.247a1.125 1.125 0 01.242-1.41l1.028-.937c.28-.254.434.62.434.995s-.154-.74-.434-.995l-1.028-.937a1.125 1.125 0 01-.242-1.41l1.296-2.247a1.125 1.125 0 011.37.49l1.217.456c.355.133.75.072 1.075-.124.073-.044.146-.087.22-.127.332-.183.582-.495.645-.87l.213-1.281z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
      );

      const SunIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.95-4.223-1.591 1.591M5.25 12H3m4.223-4.95-1.591-1.591M12 6a6 6 0 1 0 0 12 6 6 0 0 0 0-12Z" />
          </svg>
      );

      const MoonIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25c0 5.385 4.365 9.75 9.75 9.75 2.806 0 5.347-1.257 7.141-3.248a9.753 9.753 0 0 1 1.861-3.75Z" />
          </svg>
      );
      // --- END: components/Icons.tsx ---


      // --- START: components/LinkPopup.tsx ---
      const LinkPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
        const { useEffect, useRef } = React;
        const selectedItemRef = useRef(null);
        
        useEffect(() => {
          if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        if (suggestions.length === 0) {
          return null;
        }

        return (
          <div
            className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-full max-w-2xl"
            style={{ top: position.top, left: position.left }}
          >
            <ul ref={containerRef}>
              {suggestions.map((bullet, index) => (
                <li key={bullet.id} ref={index === selectedIndex ? selectedItemRef : null}>
                  <button
                    onClick={() => onSelect(bullet)}
                    className={`w-full text-left px-3 py-2 text-sm ${
                      index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                    }`}
                     title={bullet.text}
                  >
                    <span className="truncate block">{bullet.text || <em>Untitled</em>}</span>
                    {bullet.path.length > 0 && (
                        <span className={`text-xs truncate block ${
                          index === selectedIndex ? 'text-white/80' : 'text-gray-400 dark:text-gray-500'
                        }`}>{bullet.path.join(' / ')}</span>
                    )}
                  </button>
                </li>
              ))}
            </ul>
          </div>
        );
      };
      // --- END: components/LinkPopup.tsx ---


      // --- START: components/TagPopup.tsx ---
      const TagPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
        const { useEffect, useRef } = React;
        const selectedItemRef = useRef(null);
        
        useEffect(() => {
          if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        if (suggestions.length === 0) {
          return null;
        }

        return (
          <div
            className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-auto min-w-[150px]"
            style={{ top: position.top, left: position.left }}
          >
            <ul ref={containerRef}>
              {suggestions.map((tag, index) => (
                <li key={tag} ref={index === selectedIndex ? selectedItemRef : null}>
                  <button
                    onClick={() => onSelect(tag)}
                    className={`w-full text-left px-3 py-2 text-sm ${
                      index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                    }`}
                     title={tag}
                  >
                    <span className="truncate block">{tag}</span>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        );
      };
      // --- END: components/TagPopup.tsx ---


      // --- START: components/Toolbar.tsx ---
      const Toolbar = ({
        onImport,
        onExport,
        breadcrumbs,
        onBreadcrumbClick,
        fileName,
        onOpenSettings,
        onGoToToday,
        theme,
        onThemeToggle,
        onOpenSearch,
      }) => {
        const { useRef } = React;
        const fileInputRef = useRef(null);

        const handleImportClick = () => {
          fileInputRef.current?.click();
        };

        const handleFileChange = (event) => {
          const file = event.target.files?.[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const content = e.target?.result;
                const data = JSON.parse(content);
                // Basic validation
                if (Array.isArray(data) && data.every(item => 'id' in item && 'text' in item)) {
                  onImport(data);
                } else {
                  alert('Invalid JSON file format.');
                }
              } catch (error) {
                alert('Error parsing JSON file.');
                console.error(error);
              }
            };
            reader.readAsText(file);
          }
           // Reset file input to allow re-uploading the same file
          if(event.target) {
              event.target.value = '';
          }
        };

        return (
          <div className="flex-shrink-0 sticky top-0 z-20 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-2 flex items-center gap-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
              <div className="flex-grow flex items-center gap-2 overflow-hidden">
                  <button onClick={() => onBreadcrumbClick(null)} className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <HomeIcon />
                  </button>
                  {breadcrumbs.map((crumb, index) => (
                      <React.Fragment key={crumb.id}>
                      <span className="text-gray-400 dark:text-gray-500">/</span>
                      <button
                          onClick={() => onBreadcrumbClick(crumb.id)}
                          className="px-2 py-1 text-sm text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors truncate"
                          title={crumb.text}
                      >
                          {crumb.text || <em>Untitled</em>}
                      </button>
                      </React.Fragment>
                  ))}
              </div>

            <div className="flex items-center gap-2">
               <button onClick={onOpenSearch} title="Quick Find (Ctrl+Shift+K)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                  <SearchIcon />
              </button>
              <button onClick={onGoToToday} title="Go to Today's Log (Ctrl+J)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                  <AppointmentIcon className="w-5 h-5" />
              </button>

              <div className="flex items-center gap-1">
                  <input
                      type="file"
                      ref={fileInputRef}
                      className="hidden"
                      accept=".json"
                      onChange={handleFileChange}
                  />
                  <button onClick={handleImportClick} title="Import from JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <UploadIcon />
                  </button>
                  <button onClick={onExport} title="Export to JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <DownloadIcon />
                  </button>
                  <button onClick={onThemeToggle} title="Toggle Theme" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      {theme === 'dark' ? <SunIcon /> : <MoonIcon />}
                  </button>
                  <button onClick={onOpenSettings} title="Settings" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <SettingsIcon />
                  </button>
              </div>
            </div>
          </div>
        );
      };
      // --- END: components/Toolbar.tsx ---


      // --- START: components/SearchModal.tsx ---
      const SearchModal = ({ isOpen, onClose, bullets, onNavigate, allTags }) => {
        const { useState, useEffect, useMemo, useRef, useCallback } = React;
        const [query, setQuery] = useState('');
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [activeTab, setActiveTab] = useState('search');
        const inputRef = useRef(null);
        const listRef = useRef(null);
        const selectedItemRef = useRef(null);
        const tagPopupRef = useRef(null);

        const [tagPopupState, setTagPopupState] = useState({
          isOpen: false,
          suggestions: [],
          selectedIndex: 0,
        });

        useEffect(() => {
          if (isOpen) {
            inputRef.current?.focus();
            setQuery('');
            setSelectedIndex(0);
            setActiveTab('search');
            handleCloseTagPopup();
          }
        }, [isOpen]);
        
        useEffect(() => {
          setSelectedIndex(0);
        }, [query, activeTab]);

        const listContent = useMemo(() => {
          let sourceList;
          
          if (activeTab === 'edited') {
              sourceList = [...bullets].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
          } else if (activeTab === 'created') {
              sourceList = [...bullets].sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
          } else {
              sourceList = bullets;
          }

          const trimmedQuery = query.trim();
          if (!trimmedQuery) {
            return sourceList;
          }

          const lowerCaseQuery = trimmedQuery.toLowerCase();
          const orClauses = lowerCaseQuery.split(/\s+or\s+/i);
          const searchConditionGroups = orClauses.map(clause => 
              clause.split(/\s+/).filter(term => term)
          );

          return sourceList.filter(bullet => {
              const lowerCaseText = bullet.text.toLowerCase();
              return searchConditionGroups.some(andTerms => {
                  return andTerms.every(term => lowerCaseText.includes(term));
              });
          });
        }, [query, bullets, activeTab]);

        useEffect(() => {
          if (selectedItemRef.current) {
            selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        const handleCloseTagPopup = useCallback(() => {
          setTagPopupState(prev => (prev.isOpen ? { ...prev, isOpen: false } : prev));
        }, []);

        const handleTagSelection = useCallback((selectedTag) => {
          const input = inputRef.current;
          if (!input) return;

          const text = input.value;
          const cursor = input.selectionStart ?? text.length;

          const textBeforeCursor = text.substring(0, cursor);
          const match = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);

          if (match) {
              const startIndex = match.index + (match[0].startsWith(' ') ? 1 : 0);
              const newText = text.substring(0, startIndex) + selectedTag + ' ' + text.substring(cursor);
              setQuery(newText);
              handleCloseTagPopup();

              setTimeout(() => {
                  const newCursorPos = startIndex + selectedTag.length + 1;
                  input.focus();
                  input.setSelectionRange(newCursorPos, newCursorPos);
              }, 0);
          }
        }, [handleCloseTagPopup]);

        const handleQueryChange = (e) => {
          const text = e.target.value;
          const cursor = e.target.selectionStart;
          setQuery(text);

          if (cursor === null) {
            handleCloseTagPopup();
            return;
          }

          const textBeforeCursor = text.substring(0, cursor);
          const tagMatch = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);
          
          if (tagMatch) {
              const query = tagMatch[1];
              const lowerCaseQuery = query.toLowerCase();
              const suggestions = allTags.filter(tag => tag.toLowerCase().includes(lowerCaseQuery));

              if (suggestions.length > 0) {
                  setTagPopupState({
                      isOpen: true,
                      suggestions: suggestions.slice(0, 100),
                      selectedIndex: 0,
                  });
              } else {
                  handleCloseTagPopup();
              }
          } else {
              handleCloseTagPopup();
          }
        };

        const handleKeyDown = (e) => {
          if (tagPopupState.isOpen && tagPopupState.suggestions.length > 0) {
              let handled = true;
              switch (e.key) {
                  case 'ArrowUp':
                      setTagPopupState(prev => ({
                          ...prev,
                          selectedIndex: (prev.selectedIndex - 1 + prev.suggestions.length) % prev.suggestions.length,
                      }));
                      break;
                  case 'ArrowDown':
                      setTagPopupState(prev => ({
                          ...prev,
                          selectedIndex: (prev.selectedIndex + 1) % prev.suggestions.length,
                      }));
                      break;
                  case 'Tab':
                      const selectedTag = tagPopupState.suggestions[tagPopupState.selectedIndex];
                      handleTagSelection(selectedTag);
                      break;
                  case 'Escape':
                      handleCloseTagPopup();
                      break;
                  default:
                      handled = false;
              }
              if (handled) {
                  e.preventDefault();
                  return;
              }
          }

          if (e.ctrlKey) {
              const tabs = ['search', 'edited', 'created'];
              const currentIndex = tabs.indexOf(activeTab);
              let handled = true;

              if (e.key === 'ArrowRight') {
                  const nextIndex = (currentIndex + 1) % tabs.length;
                  setActiveTab(tabs[nextIndex]);
              } else if (e.key === 'ArrowLeft') {
                  const nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                  setActiveTab(tabs[nextIndex]);
              } else {
                  handled = false;
              }

              if (handled) {
                  e.preventDefault();
                  return;
              }
          }

          const count = listContent.length;
          if (e.key === 'Escape') {
            onClose();
            return;
          }

          if (count === 0 && e.key !== 'Enter') return;

          if (e.key === 'ArrowDown') {
            e.preventDefault();
            setSelectedIndex(prev => (prev + 1) % count);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            setSelectedIndex(prev => (prev - 1 + count) % count);
          } else if (e.key === 'Enter') {
            e.preventDefault();
            if (listContent.length > 0 && listContent[selectedIndex]) {
              onNavigate(listContent[selectedIndex].id);
            }
          }
        };

        const highlightMatch = (text, q) => {
            const trimmedQuery = q.trim();
            if (!trimmedQuery || !text) return text;
            const termsToHighlight = trimmedQuery.toLowerCase().replace(/\s+or\s+/gi, ' ').split(/\s+/).filter(Boolean);
            const uniqueTerms = [...new Set(termsToHighlight)];
            if (uniqueTerms.length === 0) return text;
            const regex = new RegExp(`(${uniqueTerms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'gi');
            const parts = text.split(regex);
            return (
                <span>
                    {parts.map((part, i) => {
                        if (part && uniqueTerms.some(term => term === part.toLowerCase())) {
                            return <span key={i} className="bg-yellow-400/40 dark:bg-yellow-600/40 rounded-sm">{part}</span>;
                        }
                        return part;
                    })}
                </span>
            );
        };

        const formatDateTime = (timestamp) => {
          if (!timestamp) return '';
          const date = new Date(timestamp);
          return date.toLocaleString(undefined, {
            year: 'numeric', month: 'short', day: 'numeric',
            hour: 'numeric', minute: '2-digit', hour12: false,
          });
        };

        if (!isOpen) {
          return null;
        }

        return (
          <div
            className="fixed inset-0 bg-black/40 dark:bg-black/60 z-30 flex justify-center items-start pt-20"
            onClick={onClose}
          >
            <div
              className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[70vh] flex flex-col"
              onClick={e => e.stopPropagation()}
            >
              <div className="p-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
                  <div className="relative">
                      <span className="absolute inset-y-0 left-0 flex items-center pl-3">
                          <SearchIcon />
                      </span>
                      <input
                          ref={inputRef}
                          type="text"
                          placeholder="Quick find... (use #tag, AND, OR)"
                          value={query}
                          onChange={handleQueryChange}
                          onKeyDown={handleKeyDown}
                          className="w-full bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 pl-10 pr-4 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"
                      />
                       {tagPopupState.isOpen && inputRef.current && (
                          <TagPopup
                              suggestions={tagPopupState.suggestions}
                              selectedIndex={tagPopupState.selectedIndex}
                              onSelect={handleTagSelection}
                              position={{
                                  top: inputRef.current.offsetHeight + 4,
                                  left: 0
                              }}
                              containerRef={tagPopupRef}
                          />
                      )}
                  </div>
                  <div className="mt-3 flex border-b border-gray-200 dark:border-gray-700 text-sm">
                      {(['search', 'edited', 'created']).map(tab => (
                          <button
                              key={tab}
                              onClick={() => setActiveTab(tab)}
                              className={`px-4 py-2 capitalize -mb-px border-b-2 transition-colors ${
                                  activeTab === tab 
                                      ? 'border-[var(--main-color)] text-[var(--main-color)]' 
                                      : 'border-transparent text-gray-500 hover:text-gray-800 dark:hover:text-gray-200'
                              }`}
                          >
                              {tab === 'edited' ? 'Recently modified' : (tab === 'created' ? 'Recently created' : 'Search')}
                          </button>
                      ))}
                  </div>
              </div>

              <div className="overflow-y-auto">
                {listContent.length > 0 ? (
                  <ul ref={listRef}>
                    {listContent.map((bullet, index) => (
                      <li
                        key={bullet.id}
                        ref={index === selectedIndex ? selectedItemRef : null}
                        className={`cursor-pointer transition-colors duration-75 ${index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'}`}
                        onClick={() => onNavigate(bullet.id)}
                      >
                        <div className="px-4 py-2 border-b border-gray-200/50 dark:border-gray-700/50">
                          <div className="flex justify-between items-start gap-4">
                              <div className={`text-sm font-medium truncate mb-1 flex-grow ${index === selectedIndex ? 'text-white' : 'text-gray-800 dark:text-gray-200'}`}>
                                  {highlightMatch(bullet.text, query) || <em>Untitled</em>}
                              </div>
                              <div className={`text-xs flex-shrink-0 whitespace-nowrap ${index === selectedIndex ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'}`}>
                                  {formatDateTime(activeTab === 'created' ? bullet.createdAt : bullet.updatedAt)}
                              </div>
                          </div>
                          <div className={`text-xs flex flex-wrap items-center gap-1 leading-none ${
                              index === selectedIndex ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'
                          }`}>
                              {bullet.path.length > 0 ? (
                                  bullet.path.map((segment, i) => (
                                      <React.Fragment key={i}>
                                          <span className="truncate max-w-[200px]" title={segment}>{segment}</span>
                                          {i < bullet.path.length - 1 && (
                                              <span className="opacity-50 flex-shrink-0">/</span>
                                          )}
                                      </React.Fragment>
                                  ))
                              ) : (
                                   <span className="italic opacity-50">Top level</span>
                              )}
                          </div>
                        </div>
                      </li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-gray-400 dark:text-gray-500 p-4 text-center">No results found.</p>
                )}
              </div>
            </div>
          </div>
        );
      };
      // --- END: components/SearchModal.tsx ---


      // --- START: components/BulletItem.tsx ---
      const highlightText = (text, highlight) => {
          if (!text) return text;
          const regex = highlight ? new RegExp(`(${highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi') : null;
          const parts = highlight ? text.split(regex) : [text];
          
          return (
            <React.Fragment>
              {parts.map((part, i) => {
                  if (!part) return null;
                  const lines = part.split('\n');
                  const partWithBreaks = lines.map((line, j) => (
                      <React.Fragment key={j}>
                          {line}
                          {j < lines.length - 1 && <br />}
                      </React.Fragment>
                  ));

                  if (highlight && part.toLowerCase() === highlight.toLowerCase()) {
                      return (
                          <span key={i} className="bg-yellow-300/80 dark:bg-yellow-500/50 text-black dark:text-white rounded-sm">
                              {partWithBreaks}
                          </span>
                      );
                  }
                  return <React.Fragment key={i}>{partWithBreaks}</React.Fragment>;
              })}
            </React.Fragment>
          );
      };

      const renderRichTextContent = (
          text, 
          highlight, 
          onLinkClick,
          options = {}
      ) => {
          const { renderTagsOnly = false } = options;
          if (!text) return null;

          if (renderTagsOnly) {
              const tagRegex = /(#\w+)/g;
              const parts = text.split(tagRegex);
              return (
                  <React.Fragment>
                      {parts.map((part, index) => {
                          if (part.startsWith('#') && /#\w+/.test(part)) {
                              return (
                                  <span key={index} className="tag-span">
                                      {part}
                                  </span>
                              );
                          }
                          return <span key={index}>{part}</span>;
                      })}
                  </React.Fragment>
              );
          }
          
          const combinedRegex = /(#\w+|\[\[.*?\]\]|\[[^\]]+?\]\([^)]+?\)|\b(?:https?|ftp):\/\/[^\s/$.?#].[^\s]*|\bwww\.[^\s/$.?#].[^\s]*|[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g;
          const parts = text.split(combinedRegex);
          
          return (
            <React.Fragment>
              {parts.map((part, index) => {
                  if (!part) return null;
                  
                  if (part.startsWith('#') && /#\w+/.test(part)) {
                      return (
                          <span key={index} className="tag-span">
                               {highlightText(part, highlight)}
                          </span>
                      );
                  }

                  if (part.startsWith('[[') && part.endsWith(']]')) {
                      const linkText = part.slice(2, -2);
                      return (
                          <button key={index} onClick={() => onLinkClick(linkText)} className="bg-[var(--main-color)]/20 hover:bg-[var(--main-color)]/30 text-[var(--main-color)] rounded-sm px-1 py-0 mx-px transition-colors" title={`Go to: ${linkText}`}>
                              {highlightText(linkText, highlight)}
                          </button>
                      );
                  }
                  
                  const mdLinkMatch = part.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
                  if (mdLinkMatch) {
                      const [, text, url] = mdLinkMatch;
                      let href = url.trim();
                      if (!/^(https?|ftp|mailto):/i.test(href)) {
                         href = `https://${href}`;
                      }
                      return (
                          <a key={index} href={href} target="_blank" rel="noopener noreferrer" title={`Opens: ${href}`} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">
                             {highlightText(text, highlight)}
                          </a>
                      );
                  }

                  if (/^(https?|ftp):\/\//.test(part) || part.startsWith('www.')) {
                      const href = part.startsWith('www.') ? `https://${part}` : part;
                      return (
                          <a key={index} href={href} target="_blank" rel="noopener noreferrer" title={`Opens: ${href}`} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">
                              {highlightText(part, highlight)}
                          </a>
                      );
                  }

                  if (/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(part)) {
                      return (
                          <a key={index} href={`mailto:${part}`} title={`Email: ${part}`} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">
                              {highlightText(part, highlight)}
                          </a>
                      );
                  }

                  return highlightText(part, highlight);
              })}
            </React.Fragment>
          );
      };

      const BulletItem = ({
        bullet,
        level,
        onUpdate,
        onAddSibling,
        onDelete,
        onIndent,
        onOutdent,
        onFocusChange,
        onZoom,
        onFocusMove,
        onFocusParent,
        onFocusChild,
        onFoldAll,
        onMoveBullet,
        currentFocusId,
        focusPosition,
        searchQuery,
        onLinkClick,
        onTriggerLinkPopup,
        onCloseLinkPopup,
        onLinkNavigate,
        onLinkSelect,
        isLinkPopupOpen,
        linkPopupTargetId,
        onTriggerTagPopup,
        onCloseTagPopup,
        onTagNavigate,
        onTagSelect,
        isTagPopupOpen,
        tagPopupTargetId,
        isJournalRoot,
        onNavigateTo,
      }) => {
        const { useState, useRef, useEffect, useCallback, useMemo } = React;
        const [isEditing, setIsEditing] = useState(false);
        const textInputRef = useRef(null);

        const isFocused = currentFocusId === bullet.id;
        
        useEffect(() => {
          if (isFocused) {
            setIsEditing(true);
          } else {
            setIsEditing(false);
            onCloseLinkPopup();
            onCloseTagPopup();
          }
        }, [isFocused, onCloseLinkPopup, onCloseTagPopup]);

        useEffect(() => {
          if (isEditing && textInputRef.current) {
              textInputRef.current.focus();
              if (focusPosition === 'start') {
                  textInputRef.current.setSelectionRange(0, 0);
              } else { // 'end'
                  const len = textInputRef.current.value.length;
                  textInputRef.current.setSelectionRange(len, len);
              }
          }
        }, [isEditing, focusPosition]);
          
        useEffect(() => {
          if (isEditing && textInputRef.current) {
            textInputRef.current.style.height = 'auto';
            textInputRef.current.style.height = `${textInputRef.current.scrollHeight}px`;
          }
        }, [isEditing, bullet.text]);

        const hasChildren = bullet.children.length > 0;

        const handleLinkSelection = useCallback((selectedBullet) => {
          const input = textInputRef.current;
          if (!input) return;

          const text = input.value;
          const cursor = input.selectionStart ?? text.length;
          
          const textBeforeCursor = text.substring(0, cursor);
          const lastOpen = textBeforeCursor.lastIndexOf('[[');

          if (lastOpen !== -1) {
              const newText = text.substring(0, lastOpen) + `[[${selectedBullet.text}]]` + text.substring(cursor);
              onUpdate(bullet.id, { text: newText });
              onCloseLinkPopup();

              setTimeout(() => {
                  const newCursorPos = (text.substring(0, lastOpen) + `[[${selectedBullet.text}]]`).length;
                  input.focus();
                  input.setSelectionRange(newCursorPos, newCursorPos);
              }, 0);
          }
        }, [bullet.id, onUpdate, onCloseLinkPopup]);
        
        const handleTagSelection = useCallback((selectedTag) => {
          const input = textInputRef.current;
          if (!input) return;

          const text = input.value;
          const cursor = input.selectionStart ?? text.length;
          
          const textBeforeCursor = text.substring(0, cursor);
          const match = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);

          if (match) {
              const startIndex = match.index + (match[0].startsWith(' ') ? 1 : 0);
              const newText = text.substring(0, startIndex) + selectedTag + ' ' + text.substring(cursor);
              onUpdate(bullet.id, { text: newText });
              onCloseTagPopup();

              setTimeout(() => {
                  const newCursorPos = startIndex + selectedTag.length + 1; // +1 for the space
                  input.focus();
                  input.setSelectionRange(newCursorPos, newCursorPos);
              }, 0);
          }
        }, [bullet.id, onUpdate, onCloseTagPopup]);

        const handleTextChange = (e) => {
          const text = e.target.value;
          const cursor = e.target.selectionStart;
          onUpdate(bullet.id, { text });

          const textBeforeCursor = text.substring(0, cursor ?? 0);
          
          const lastOpenBracket = textBeforeCursor.lastIndexOf('[[');
          if (lastOpenBracket !== -1 && textBeforeCursor.lastIndexOf(']]') < lastOpenBracket) {
            const query = textBeforeCursor.substring(lastOpenBracket + 2);
            onTriggerLinkPopup(bullet.id, query, textInputRef, handleLinkSelection);
            return;
          }

          const tagMatch = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);
          if (tagMatch) {
              const query = tagMatch[1];
              onTriggerTagPopup(bullet.id, query, textInputRef, handleTagSelection);
              return;
          }

          onCloseLinkPopup();
          onCloseTagPopup();
        };

        const handleTextKeyDown = (e) => {
          const input = e.target;
          const isPopupActive = isLinkPopupOpen && linkPopupTargetId === bullet.id;
          const isTagPopupActive = isTagPopupOpen && tagPopupTargetId === bullet.id;
          
          if (bullet.isReadOnly) {
              let handled = true;
              if (e.ctrlKey) {
                  switch (e.key) {
                      case 'ArrowLeft':
                          if (hasChildren && !bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: true }, false);
                          else if (level > 0) onFocusParent(bullet.id);
                          break;
                      case 'ArrowRight':
                          if (hasChildren && bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: false }, false);
                          break;
                      case 'ArrowDown':
                          onZoom(bullet.id);
                          break;
                      default:
                          handled = false;
                  }
              } else {
                  switch(e.key) {
                      case 'Enter':
                          if (bullet.originalId) {
                              onNavigateTo(bullet.originalId);
                          } else if (hasChildren) {
                              onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed }, false);
                          }
                          break;
                      case 'ArrowUp': onFocusMove('up'); break;
                      case 'ArrowDown': onFocusMove('down'); break;
                      case 'ArrowLeft': onFocusParent(bullet.id); break;
                      case 'ArrowRight': 
                          if(hasChildren && !bullet.isCollapsed) onFocusChild(bullet.id);
                          else onFocusMove('down', 'start'); 
                          break;
                      default: handled = false;
                  }
              }

              if (handled) {
                  e.preventDefault();
              }
              return;
          }

          if (isTagPopupActive) {
              let handled = true;
              switch (e.key) {
                  case 'ArrowUp': onTagNavigate('up'); break;
                  case 'ArrowDown': onTagNavigate('down'); break;
                  case 'Tab': onTagSelect(handleTagSelection); break;
                  case 'Escape': onCloseTagPopup(); break;
                  default: handled = false;
              }
              if (handled) { e.preventDefault(); return; }
          }

          if (isPopupActive) {
              let handled = true;
              switch (e.key) {
                  case 'ArrowUp': onLinkNavigate('up'); break;
                  case 'ArrowDown': onLinkNavigate('down'); break;
                  case 'Enter': onLinkSelect(handleLinkSelection); break;
                  case 'Tab': onLinkSelect(handleLinkSelection); break;
                  case 'Escape': {
                      onCloseLinkPopup();
                      const text = input.value;
                      const cursor = input.selectionStart ?? text.length;
                      const textBeforeCursor = text.substring(0, cursor);
                      const lastOpen = textBeforeCursor.lastIndexOf('[[');
                      if (lastOpen !== -1 && textBeforeCursor.lastIndexOf(']]') < lastOpen) {
                          const newText = text.substring(0, lastOpen) + text.substring(cursor);
                          onUpdate(bullet.id, { text: newText });
                          setTimeout(() => {
                              if(textInputRef.current) {
                                  textInputRef.current.focus();
                                  textInputRef.current.setSelectionRange(lastOpen, lastOpen);
                              }
                          }, 0);
                      }
                      break;
                  }
                  default: handled = false;
              }
              if (handled) { e.preventDefault(); return; }
          }

          if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
              e.preventDefault();
              const start = input.selectionStart;
              const end = input.selectionEnd;
              const text = input.value;
              const selectedText = text.substring(start, end);

              let newText;
              let newCursorPosStart;
              let newCursorPosEnd;

              if (selectedText) {
                  newText = `${text.substring(0, start)}[${selectedText}]()${text.substring(end)}`;
                  newCursorPosStart = newCursorPosEnd = start + selectedText.length + 3;
              } else {
                  newText = `${text.substring(0, start)}[link text]()${text.substring(end)}`;
                  newCursorPosStart = start + 1;
                  newCursorPosEnd = start + 1 + 'link text'.length;
              }

              onUpdate(bullet.id, { text: newText });

              setTimeout(() => {
                  if (textInputRef.current) {
                      textInputRef.current.focus();
                      textInputRef.current.setSelectionRange(newCursorPosStart, newCursorPosEnd);
                  }
              }, 0);
              return;
          }


          if (e.altKey) {
              if (e.key === 'ArrowUp') { e.preventDefault(); onMoveBullet(bullet.id, 'up'); return; }
              if (e.key === 'ArrowDown') { e.preventDefault(); onMoveBullet(bullet.id, 'down'); return; }
          }

          if (e.ctrlKey && e.shiftKey) {
              if (e.key === 'ArrowLeft') { e.preventDefault(); onFoldAll(bullet.id, true); return; }
              if (e.key === 'ArrowRight') { e.preventDefault(); onFoldAll(bullet.id, false); return; }
          }

          if (e.ctrlKey) {
              let handled = true;
              switch (e.key) {
                  case 'ArrowLeft':
                      if (hasChildren && !bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: true }, false);
                      else if (level > 0) onFocusParent(bullet.id);
                      break;
                  case 'ArrowRight':
                      if (hasChildren && bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: false }, false);
                      else if (hasChildren && !bullet.isCollapsed) onFocusChild(bullet.id);
                      break;
                  case 'ArrowDown': onZoom(bullet.id); break;
                  default: handled = false;
              }
              if (handled) { e.preventDefault(); return; }
          }

          switch (e.key) {
            case 'Enter':
              e.preventDefault();
              if (e.shiftKey) {
                  const { value, selectionStart, selectionEnd } = input;
                  const newValue = value.substring(0, selectionStart) + '\n' + value.substring(selectionEnd);
                  onUpdate(bullet.id, { text: newValue });

                  setTimeout(() => {
                      if (textInputRef.current) {
                          const newCursorPos = selectionStart + 1;
                          textInputRef.current.focus();
                          textInputRef.current.setSelectionRange(newCursorPos, newCursorPos);
                      }
                  }, 0);
              } else {
                  const { value, selectionStart } = input;
                  const textBeforeCursor = value.substring(0, selectionStart);
                  const textAfterCursor = value.substring(selectionStart);
                  
                  onUpdate(bullet.id, { text: textBeforeCursor });
                  onAddSibling(bullet.id, textAfterCursor);
              }
              break;
            case 'Tab':
              e.preventDefault();
              if (e.shiftKey) onOutdent(bullet.id);
              else onIndent(bullet.id);
              break;
            case 'Backspace':
              if (bullet.text === '') {
                e.preventDefault();
                onDelete(bullet.id);
              }
              break;
            case 'ArrowUp': e.preventDefault(); onFocusMove('up'); break;
            case 'ArrowDown': e.preventDefault(); onFocusMove('down'); break;
            case 'ArrowLeft':
              if (input.selectionStart === 0) { e.preventDefault(); onFocusParent(bullet.id); }
              break;
            case 'ArrowRight':
              if (input.selectionStart === input.value.length) { e.preventDefault(); onFocusMove('down', 'start'); }
              break;
          }
        };

        const toggleCollapse = () => {
          if (hasChildren) {
            onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed }, false);
          }
        };

        const matchesSearch = (b, q) => {
            if (!q) return true;
            const query = q.toLowerCase();
            const textMatch = b.text.toLowerCase().includes(query);
            const childrenMatch = b.children.some(child => matchesSearch(child, q));
            return textMatch || childrenMatch;
        };

        const renderedRichText = useMemo(() => {
          return renderRichTextContent(bullet.text, searchQuery, onLinkClick);
        }, [bullet.text, searchQuery, onLinkClick]);
        
        const renderedRichTextSimple = useMemo(() => {
          return renderRichTextContent(bullet.text, undefined, () => {}, { renderTagsOnly: true });
        }, [bullet.text]);

        if (searchQuery && !matchesSearch(bullet, searchQuery)) {
            return null;
        }

        const circleColor = 'var(--main-color)';
        
        const handleTextClick = () => {
          if (bullet.isReadOnly) {
              if (bullet.originalId) {
                  onNavigateTo(bullet.originalId);
              } else {
                  onFocusChange(bullet.id);
              }
          } else {
              onFocusChange(bullet.id);
          }
        };

        const renderBulletIcon = () => {
          if (isJournalRoot) return <AppointmentIcon className="w-4 h-4" />;
          return <CircleIcon className="w-2 h-2" color={circleColor} />;
        }

        return (
          <div className="flex flex-col group">
              <div className={`flex items-start py-1 relative ${isFocused ? 'bg-blue-100 dark:bg-gray-800/[.6] rounded' : ''}`}>
                  <div
                      style={{ marginLeft: `${level * 1.5}rem` }}
                      className="flex-shrink-0 flex items-center h-6 text-[var(--main-color)]"
                  >
                      <button
                          onClick={toggleCollapse}
                          className={`transition-opacity duration-150 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 ${hasChildren ? 'opacity-100 cursor-pointer' : 'opacity-0 cursor-default'}`}
                          aria-label={bullet.isCollapsed ? 'Expand' : 'Collapse'}
                      >
                          {bullet.isCollapsed ? <ChevronRightIcon /> : <ChevronDownIcon />}
                      </button>
                      <button onClick={() => onZoom(bullet.id)} className="ml-1 w-6 h-6 flex items-center justify-center transition-colors" aria-label="Zoom in">
                          {renderBulletIcon()}
                      </button>
                  </div>
                  <div className="flex-grow ml-2">
                      <div className="flex items-center">
                          <div className="flex-grow">
                              {isEditing ? (
                                  <div className="relative">
                                      <div
                                          className="absolute top-0 left-0 w-full h-full pointer-events-none leading-6 whitespace-pre-wrap break-words"
                                          aria-hidden="true"
                                      >
                                          {renderedRichTextSimple}
                                      </div>
                                      <textarea
                                          ref={textInputRef}
                                          value={bullet.text}
                                          onChange={handleTextChange}
                                          onKeyDown={handleTextKeyDown}
                                          readOnly={bullet.isReadOnly}
                                          className="w-full bg-transparent outline-none text-transparent caret-gray-800 dark:caret-gray-200 resize-none overflow-hidden leading-6"
                                          rows={1}
                                          aria-label="Edit item"
                                      />
                                  </div>
                              ) : (
                                  <div onClick={handleTextClick} className={`w-full min-h-[1.5rem] leading-6 break-words ${bullet.isReadOnly ? 'cursor-text' : ''}`}>
                                  {bullet.text ? renderedRichText : <span className="text-gray-400 dark:text-gray-500">...</span>}
                                  </div>
                              )}
                          </div>
                      </div>
                  </div>
              </div>
            {!bullet.isCollapsed && hasChildren && (
              <div className="border-l border-gray-300 dark:border-gray-700/50">
                {bullet.children.map((child) => (
                  <BulletItem
                      key={child.id}
                      bullet={child}
                      level={level + 1}
                      onUpdate={onUpdate}
                      onAddSibling={onAddSibling}
                      onDelete={onDelete}
                      onIndent={onIndent}
                      onOutdent={onOutdent}
                      onFocusChange={onFocusChange}
                      onZoom={onZoom}
                      onFocusMove={onFocusMove}
                      onFocusParent={onFocusParent}
                      onFocusChild={onFocusChild}
                      onFoldAll={onFoldAll}
                      onMoveBullet={onMoveBullet}
                      currentFocusId={currentFocusId}
                      focusPosition={focusPosition}
                      searchQuery={searchQuery}
                      onLinkClick={onLinkClick}
                      onTriggerLinkPopup={onTriggerLinkPopup}
                      onCloseLinkPopup={onCloseLinkPopup}
                      onLinkNavigate={onLinkNavigate}
                      onLinkSelect={onLinkSelect}
                      isLinkPopupOpen={isLinkPopupOpen}
                      linkPopupTargetId={linkPopupTargetId}
                      onTriggerTagPopup={onTriggerTagPopup}
                      onCloseTagPopup={onCloseTagPopup}
                      onTagNavigate={onTagNavigate}
                      onTagSelect={onTagSelect}
                      isTagPopupOpen={isTagPopupOpen}
                      tagPopupTargetId={tagPopupTargetId}
                      isJournalRoot={false}
                      onNavigateTo={onNavigateTo}
                  />
                ))}
              </div>
            )}
          </div>
        );
      };
      // --- END: components/BulletItem.tsx ---


      // --- START: App.tsx ---
      class JaroetDatabase extends Dexie {
          keyValuePairs;

          constructor() {
              super("JaroetOutlinerDB");
              this.version(1).stores({
                  keyValuePairs: 'key', 
              });
              this.keyValuePairs = this.table('keyValuePairs');
          }
      }

      const db = new JaroetDatabase();

      const DAILY_LOG_ROOT_TEXT = 'Daily Log';

      const initialData = [
        {
          id: 'journal-root',
          text: DAILY_LOG_ROOT_TEXT,
          children: [],
          isCollapsed: true,
        },
        {
          id: 'doc-root',
          text: 'Help & Documentation',
          children: [
            {
              id: 'help-placeholder',
              text: 'To view the full documentation and changelog, import the `help-documentation.json` file using the "Import from JSON" button in the toolbar.',
              children: [],
              isCollapsed: false,
            },
          ],
          isCollapsed: true,
        },
      ];

      const createNewBullet = (text = '') => {
          const now = Date.now();
          return {
              id: crypto.randomUUID(),
              text,
              children: [],
              isCollapsed: false,
              createdAt: now,
              updatedAt: now,
          };
      };

      const migrateBullets = (nodes) => {
          const now = Date.now();
          return nodes.map(node => ({
              ...node,
              createdAt: node.createdAt || now,
              updatedAt: node.updatedAt || now,
              children: migrateBullets(node.children),
          }));
      };

      const navigateSuggestions = (
          prevState,
          direction
      ) => {
          const { suggestions, selectedIndex } = prevState;
          const count = suggestions.length;
          if (count === 0) return selectedIndex;
          if (direction === 'down') {
              return (selectedIndex + 1) % count;
          } else { // 'up'
              return (selectedIndex - 1 + count) % count;
          }
      };

      const FONT_LIST = [
        'Arial', 'Verdana', 'Helvetica', 'Tahoma', 'Trebuchet MS', 
        'Times New Roman', 'Georgia', 'Garamond', 
        'Courier New', 'Brush Script MT', 'sans-serif', 'serif', 'monospace'
      ];

      const SettingsModal = ({ isOpen, onClose, onSave, currentSettings, onClearDatabase }) => {
          const { useState, useEffect } = React;
          const [settings, setSettings] = useState(currentSettings);
          const [isConfirmingReset, setIsConfirmingReset] = useState(false);
          const [resetClickCount, setResetClickCount] = useState(0);

          useEffect(() => {
              setSettings(currentSettings);
              setIsConfirmingReset(false);
              setResetClickCount(0);
          }, [isOpen, currentSettings]);

          const handleSave = () => {
              onSave(settings);
              onClose();
          };
          
          const handleInputChange = (e) => {
              const { name, value } = e.target;
              setSettings(prev => ({...prev, [name]: value }));
          };

          const handleFontSizeChange = (e) => {
              setSettings(prev => ({...prev, fontSize: parseInt(e.target.value, 10) }));
          }

          const handleResetClick = () => {
            const newCount = resetClickCount + 1;
            setResetClickCount(newCount);
            if (newCount >= 3) {
                onClearDatabase();
            }
          };

          const handleCancelReset = () => {
              setIsConfirmingReset(false);
              setResetClickCount(0);
          };

          if (!isOpen) return null;

          return (
              <div className="fixed inset-0 bg-black/60 z-30 flex justify-center items-center" onClick={onClose}>
                  <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md" onClick={e => e.stopPropagation()}>
                      <h2 className="p-4 text-lg font-semibold border-b border-gray-200 dark:border-gray-700">Settings</h2>
                      <div className="p-4 space-y-4">
                          <div>
                              <label htmlFor="fileName" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">File Name</label>
                              <input type="text" id="fileName" name="fileName" value={settings.fileName} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"/>
                          </div>
                          <div>
                              <label htmlFor="mainColor" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Main Color</label>
                              <input type="color" id="mainColor" name="mainColor" value={settings.mainColor} onChange={handleInputChange} className="w-full h-10 p-1 bg-gray-100 dark:bg-gray-700 rounded-md cursor-pointer"/>
                          </div>
                          <div>
                              <label htmlFor="fontFamily" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font</label>
                              <select id="fontFamily" name="fontFamily" value={settings.fontFamily} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]">
                                  {FONT_LIST.map(font => <option key={font} value={font}>{font}</option>)}
                              </select>
                          </div>
                          <div>
                              <label htmlFor="fontSize" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font Size ({settings.fontSize}px)</label>
                              <input type="range" id="fontSize" name="fontSize" min="12" max="24" value={settings.fontSize} onChange={handleFontSizeChange} className="w-full"/>
                          </div>
                      </div>
                      
                      <div className="p-4 space-y-2 border-t border-gray-200 dark:border-gray-700">
                        <h3 className="text-md font-semibold text-red-600 dark:text-red-500">Danger Zone</h3>
                        {!isConfirmingReset ? (
                            <button 
                                onClick={() => setIsConfirmingReset(true)}
                                className="w-full px-4 py-2 rounded-md bg-red-600 hover:bg-red-700 text-white transition-colors"
                            >
                                Clear All Data & Reset Application
                            </button>
                        ) : (
                            <div className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-500/30 rounded-md space-y-3">
                                <p className="text-sm text-red-800 dark:text-red-200">
                                    Are you sure? This action is irreversible and will delete all your data. To proceed, click the button below 3 times.
                                </p>
                                <button
                                    onClick={handleResetClick}
                                    className="w-full px-4 py-2 rounded-md bg-red-600 hover:bg-red-700 text-white font-bold"
                                >
                                    I Agree, Delete Everything ({resetClickCount}/3)
                                </button>
                                <button
                                    onClick={handleCancelReset}
                                    className="w-full px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white"
                                >
                                    Cancel
                                </button>
                            </div>
                        )}
                      </div>

                      <div className="p-4 flex justify-end gap-2 border-t border-gray-200 dark:border-gray-700">
                          <button onClick={onClose} className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white">Cancel</button>
                          <button onClick={handleSave} className="px-4 py-2 rounded-md bg-[var(--main-color)] text-white hover:opacity-90">Save</button>
                      </div>
                  </div>
              </div>
          );
      }

      const App = () => {
          const { useState, useEffect, useCallback, useMemo, useRef } = React;
          const [bullets, setBullets] = useState(initialData);
          const [zoomedBulletId, setZoomedBulletId] = useState(null);
          const [searchQuery, setSearchQuery] = useState('');
          const [focusOptions, setFocusOptions] = useState({ id: null, position: 'end' });
          const isInitialFocusSet = useRef(false);
          const linkPopupRef = useRef(null);
          const tagPopupRef = useRef(null);
          const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
          const [linkSelectionHandler, setLinkSelectionHandler] = useState({ handler: null });
          const [tagSelectionHandler, setTagSelectionHandler] = useState({ handler: null });
          const prevFocusId = useRef(null);
          const dataLoadedRef = useRef(false);
          const prevCoreDataRef = useRef(null);
          const [theme, setTheme] = useState('dark');
          const focusBeforeModalRef = useRef(null);
          
          const [settings, setSettings] = useState({
              mainColor: '#60a5fa',
              fileName: 'My Outline',
              fontFamily: 'sans-serif',
              fontSize: 16,
          });
          const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);

          const [linkPopupState, setLinkPopupState] = useState({
              isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0
          });
          const [tagPopupState, setTagPopupState] = useState({
              isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0
          });


          const currentFocusId = focusOptions.id;
          const focusPosition = focusOptions.position;

          const handleFocusChange = useCallback((id, position = 'end') => {
              setFocusOptions({ id, position });
          }, []);

          const getCoreDataString = useCallback((nodes) => {
              const removeUiState = (b) => {
                  return {
                      id: b.id,
                      text: b.text,
                      children: b.children.map(removeUiState),
                      originalId: b.originalId,
                      createdAt: b.createdAt,
                      updatedAt: b.updatedAt,
                  };
              };
              const coreBullets = nodes.map(removeUiState);
              return JSON.stringify(coreBullets);
          }, []);

          const handleThemeToggle = useCallback(() => {
              const newTheme = theme === 'light' ? 'dark' : 'light';
              setTheme(newTheme);
              db.keyValuePairs.put({ key: 'theme', value: newTheme });
          }, [theme]);

          useEffect(() => {
              const root = window.document.documentElement;
              const isDark = theme === 'dark';
              root.classList.toggle('dark', isDark);
          }, [theme]);

          useEffect(() => {
              const loadData = async () => {
                  const savedThemeEntry = await db.keyValuePairs.get('theme');
                  const savedTheme = savedThemeEntry?.value;
                  if (savedTheme && (savedTheme === 'light' || savedTheme === 'dark')) {
                      setTheme(savedTheme);
                  }
                  
                  let loadedSettings;
                  const defaultSettings = {
                      mainColor: '#60a5fa',
                      fileName: 'My Outline',
                      fontFamily: 'sans-serif',
                      fontSize: 16,
                  };
                  try {
                      const savedSettingsEntry = await db.keyValuePairs.get('settings');
                      const savedSettings = savedSettingsEntry?.value;
                      loadedSettings = { ...defaultSettings, ...(savedSettings || {}) };
                      setSettings(loadedSettings);
                  } catch (error) {
                      console.error("Failed to load settings from IndexedDB", error);
                      loadedSettings = defaultSettings;
                  }

                  let localBullets = null;
                  try {
                      const savedDataEntry = await db.keyValuePairs.get('bullets');
                      const savedData = savedDataEntry?.value;
                      if (savedData && Array.isArray(savedData)) {
                         localBullets = savedData;
                      }
                  } catch(e) {
                     console.error("Failed to parse local data from IndexedDB", e);
                  }
                  
                  let initialLoadData = localBullets || initialData;
                  initialLoadData = migrateBullets(initialLoadData);

                  setBullets(initialLoadData);
                  prevCoreDataRef.current = getCoreDataString(initialLoadData);
          
                  setZoomedBulletId(null);
                  isInitialFocusSet.current = false;
                  dataLoadedRef.current = true;
              };

              loadData();
          }, [getCoreDataString]);

          useEffect(() => {
              if (!dataLoadedRef.current) return;
              db.keyValuePairs.put({ key: 'settings', value: settings });
              
              document.title = `${settings.fileName || 'Untitled'} - Jaroet Outliner`;
              
              const root = document.documentElement;
              root.style.setProperty('--main-color', settings.mainColor);
              root.style.setProperty('--font-family', settings.fontFamily);
              root.style.setProperty('--font-size', `${settings.fontSize}px`);
              
              db.keyValuePairs.put({ key: 'bullets', value: bullets });
              
              const currentCoreData = getCoreDataString(bullets);
              if (currentCoreData !== prevCoreDataRef.current) {
                   prevCoreDataRef.current = currentCoreData;
              }

          }, [settings, bullets, getCoreDataString]);
          
          const flatBullets = useMemo(() => {
              const results = [];
              const traverse = (nodes, currentPath) => {
                  for (const node of nodes) {
                      results.push({
                          id: node.id,
                          text: node.text,
                          path: currentPath,
                          createdAt: node.createdAt,
                          updatedAt: node.updatedAt,
                      });
                      if (node.children && node.children.length > 0) {
                          traverse(node.children, [...currentPath, node.text || 'Untitled']);
                      }
                  }
              };
              traverse(bullets, []);
              return results;
          }, [bullets]);
          
          const allTags = useMemo(() => {
              const tagSet = new Set();
              const tagRegex = /#\w+/g;
              for (const bullet of flatBullets) {
                  const matches = bullet.text.match(tagRegex);
                  if (matches) {
                      matches.forEach(tag => tagSet.add(tag));
                  }
              }
              return Array.from(tagSet).sort();
          }, [flatBullets]);


          const findBulletAndParent = useCallback((
              id,
              nodes,
              parent = null
            ) => {
              for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.id === id) {
                  return { node, parent, siblings: nodes, index: i };
                }
                const found = findBulletAndParent(id, node.children, node);
                if (found) return found;
              }
              return null;
          }, []);

          useEffect(() => {
              const currentId = focusOptions.id;
              const prevId = prevFocusId.current;

              if (prevId && prevId !== currentId) {
                  const found = findBulletAndParent(prevId, bullets);
                  if (found && !found.node.isReadOnly && found.node.text === '' && found.node.children.length === 0) {
                      const newBullets = structuredClone(bullets);
                      const foundAgain = findBulletAndParent(prevId, newBullets);
                      if (foundAgain) {
                          foundAgain.siblings.splice(foundAgain.index, 1);
                          setBullets(newBullets);
                      }
                  }
              }

              prevFocusId.current = currentId;
          }, [focusOptions.id, bullets, findBulletAndParent]);


          const breadcrumbs = useMemo(() => {
              if (!zoomedBulletId) return [];
              const path = [];
              const findPath = (nodes, currentPath) => {
                  for (const node of nodes) {
                      const newPath = [...currentPath, node];
                      if (node.id === zoomedBulletId) {
                          path.push(...newPath);
                          return true;
                      }
                      if (findPath(node.children, newPath)) return true;
                  }
                  return false;
              };
              findPath(bullets, []);
              return path;
          }, [bullets, zoomedBulletId]);
          
          const handleNavigate = useCallback((bulletId) => {
              const path = [];
              const findPath = (nodes, currentPath) => {
                  for (const node of nodes) {
                      const newPath = [...currentPath, node];
                      if (node.id === bulletId) {
                          path.push(...newPath);
                          return true;
                      }
                      if (findPath(node.children, newPath)) return true;
                  }
                  return false;
              };
              findPath(bullets, []);
          
              if (path.length > 0) {
                  const parent = path.length > 1 ? path[path.length - 2] : null;
                  setZoomedBulletId(parent ? parent.id : null);
                  setIsSearchModalOpen(false);
                  setTimeout(() => {
                      handleFocusChange(bulletId, 'end');
                  }, 0);
              }
          }, [bullets, handleFocusChange]);

          const handleZoom = useCallback((id) => {
              const oldZoomedBulletId = zoomedBulletId;
              const isZoomingOut = (id === null && oldZoomedBulletId !== null) || 
                                   (id !== null && breadcrumbs.some(b => b.id === id));
              
              if (id === null) { 
                  setZoomedBulletId(null);
                  if (oldZoomedBulletId) {
                      setTimeout(() => handleFocusChange(oldZoomedBulletId), 0);
                  } else {
                      const getVisibleIds = (nodes) => {
                          let ids = [];
                          for (const node of nodes) {
                              ids.push(node.id);
                              if (!node.isCollapsed && node.children.length > 0) {
                                  ids = ids.concat(getVisibleIds(node.children));
                              }
                          }
                          return ids;
                      };
                      const rootVisibleIds = getVisibleIds(bullets);
                      if (rootVisibleIds.length > 0) {
                          handleFocusChange(rootVisibleIds[0]);
                      }
                  }
                  return;
              }
          
              const bulletToZoom = findBulletAndParent(id, bullets)?.node;
          
              if (bulletToZoom && bulletToZoom.children.length === 0 && !bulletToZoom.isReadOnly) {
                  const newBullet = createNewBullet();
                  const newBullets = structuredClone(bullets);
                  const found = findBulletAndParent(id, newBullets);
                  if (found) {
                      found.node.children.push(newBullet);
                      found.node.isCollapsed = false;
                      found.node.updatedAt = Date.now();
                      setBullets(newBullets);
                      setZoomedBulletId(id);
                      setTimeout(() => {
                          handleFocusChange(newBullet.id);
                      }, 0);
                  } else {
                      setZoomedBulletId(id);
                  }
              } else if (bulletToZoom) {
                  setZoomedBulletId(id);
                  if (isZoomingOut && oldZoomedBulletId) {
                      setTimeout(() => handleFocusChange(oldZoomedBulletId), 0);
                  } else if (bulletToZoom.children.length > 0) {
                       const getVisibleIds = (nodes) => {
                          let ids = [];
                          for (const node of nodes) {
                              ids.push(node.id);
                              if (!node.isCollapsed && node.children.length > 0) {
                                  ids = ids.concat(getVisibleIds(node.children));
                              }
                          }
                          return ids;
                      };
                      const visibleChildrenIds = getVisibleIds(bulletToZoom.children);
                      if (visibleChildrenIds.length > 0) {
                          handleFocusChange(visibleChildrenIds[0]);
                      }
                  }
              }
          }, [zoomedBulletId, bullets, handleFocusChange, breadcrumbs, findBulletAndParent]);

          const displayedBullets = useMemo(() => {
              if (!zoomedBulletId) return bullets;
              const findZoomed = (nodes) => {
                  for (const node of nodes) {
                      if (node.id === zoomedBulletId) return node;
                      const found = findZoomed(node.children);
                      if (found) return found;
                  }
                  return null;
              }
              const zoomedNode = findZoomed(bullets);
              return zoomedNode ? zoomedNode.children : [];
          }, [bullets, zoomedBulletId]);

          const visibleBulletIds = useMemo(() => {
              const getVisibleIds = (nodes) => {
                  let ids = [];
                  for (const node of nodes) {
                      ids.push(node.id);
                      if (!node.isCollapsed && node.children.length > 0) {
                          ids = ids.concat(getVisibleIds(node.children));
                      }
                  }
                  return ids;
              };
              return getVisibleIds(displayedBullets);
          }, [displayedBullets]);
          
          useEffect(() => {
              if (!isInitialFocusSet.current && visibleBulletIds.length > 0) {
                  handleFocusChange(visibleBulletIds[0], 'end');
                  isInitialFocusSet.current = true;
              }
          }, [visibleBulletIds, handleFocusChange]);

          const handleGoToJournal = useCallback(() => {
              const now = new Date();
              const year = now.getFullYear().toString();
              const month = (now.getMonth() + 1).toString().padStart(2, '0');
              const day = now.getDate().toString().padStart(2, '0');
              const dayText = `${year}-${month}-${day}`;

              const newBullets = structuredClone(bullets);
              
              let journalNode = newBullets.find((b) => b.text === DAILY_LOG_ROOT_TEXT);
              if (!journalNode) {
                  journalNode = createNewBullet(DAILY_LOG_ROOT_TEXT);
                  newBullets.unshift(journalNode);
              }

              let yearNode = journalNode.children.find((b) => b.text === year);
              if (!yearNode) {
                  yearNode = createNewBullet(year);
                  journalNode.children.push(yearNode);
              }

              let monthNode = yearNode.children.find((b) => b.text === month);
              if (!monthNode) {
                  monthNode = createNewBullet(month);
                  yearNode.children.push(monthNode);
              }
              
              let dayNode = monthNode.children.find((b) => b.text === dayText);
              if (!dayNode) {
                  dayNode = createNewBullet(dayText);
                  monthNode.children.push(dayNode);
              }
              
              setBullets(newBullets);
              setZoomedBulletId(monthNode.id);
              setTimeout(() => handleFocusChange(dayNode.id), 0);
          }, [bullets, handleFocusChange]);

          const mapBullets = (
              nodes,
              callback
          ) => {
              return nodes.map(node => {
                  const newNode = callback(node);
                  return {
                      ...newNode,
                      children: mapBullets(newNode.children, callback),
                  };
              });
          };
          
          const handleUpdate = useCallback((id, updates, updateTimestamp = true) => {
              const found = findBulletAndParent(id, bullets);
              // Prevent content changes on read-only nodes, but allow UI changes like collapsing.
              if (found?.node.isReadOnly && updateTimestamp) return;

              setBullets(prevBullets =>
                  mapBullets(prevBullets, bullet => {
                      if (bullet.id === id) {
                          const newBullet = { ...bullet, ...updates };
                          if (updateTimestamp && !bullet.isReadOnly) {
                              newBullet.updatedAt = Date.now();
                          }
                          return newBullet;
                      }
                      return bullet;
                  })
              );
          }, [bullets, findBulletAndParent]);
          
          useEffect(() => {
              const handleGlobalKeyDown = (e) => {
                  if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'k') {
                      e.preventDefault();
                      handleOpenSearch();
                  }
                  else if (e.ctrlKey && e.key.toLowerCase() === 'j') {
                      e.preventDefault();
                      handleGoToJournal();
                  }
                  else if (e.ctrlKey && e.key === 'ArrowUp') {
                      e.preventDefault();
                      if (zoomedBulletId) {
                          const parentId = breadcrumbs.length > 1 ? breadcrumbs[breadcrumbs.length - 2].id : null;
                          handleZoom(parentId);
                      }
                  }
                  else if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && !currentFocusId && visibleBulletIds.length > 0) {
                      const target = e.target;
                      if(target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
                          e.preventDefault();
                          handleFocusChange(visibleBulletIds[0]);
                      }
                  }
              };

              window.addEventListener('keydown', handleGlobalKeyDown);
              return () => {
                  window.removeEventListener('keydown', handleGlobalKeyDown);
              };
          }, [zoomedBulletId, breadcrumbs, currentFocusId, visibleBulletIds, handleGoToJournal, handleZoom, handleFocusChange]);

          const handleAddSibling = useCallback((id, text = '') => {
              const newBullet = createNewBullet(text);
              const newBullets = structuredClone(bullets);
              const found = findBulletAndParent(id, newBullets);

              if (found) {
                  if (found.node.isReadOnly) return;
                  found.siblings.splice(found.index + 1, 0, newBullet);
                  if (found.parent) {
                      found.parent.updatedAt = Date.now();
                  }
                  setBullets(newBullets);
                  handleFocusChange(newBullet.id);
              }
          }, [bullets, handleFocusChange, findBulletAndParent]);

          const handleDelete = useCallback((id) => {
              const foundTarget = findBulletAndParent(id, bullets);
              if (foundTarget?.node.isReadOnly) return;

              const newBullets = structuredClone(bullets);
              const found = findBulletAndParent(id, newBullets);
              if (found) {
                  const prevSiblingId = found.index > 0 ? found.siblings[found.index - 1].id : found.parent?.id;
                  if (found.parent) {
                      found.parent.updatedAt = Date.now();
                  }
                  found.siblings.splice(found.index, 1);
                  setBullets(newBullets);
                  handleFocusChange(prevSiblingId || null);
              }
          }, [bullets, handleFocusChange, findBulletAndParent]);
          
          const handleIndent = useCallback((id) => {
              const foundTarget = findBulletAndParent(id, bullets);
              if (foundTarget?.node.isReadOnly) return;

              const newBullets = structuredClone(bullets);
              const found = findBulletAndParent(id, newBullets);
              if (found && found.index > 0) {
                  const prevSibling = found.siblings[found.index - 1];
                   if (prevSibling.isReadOnly) return;
                  const [movedNode] = found.siblings.splice(found.index, 1);
                  movedNode.updatedAt = Date.now();
                  prevSibling.children.push(movedNode);
                  prevSibling.isCollapsed = false;
                  setBullets(newBullets);
                  handleFocusChange(id);
              }
          }, [bullets, handleFocusChange, findBulletAndParent]);
          
          const handleOutdent = useCallback((id) => {
              const foundTarget = findBulletAndParent(id, bullets);
              if (foundTarget?.node.isReadOnly) return;

              const newBullets = structuredClone(bullets);
              const found = findBulletAndParent(id, newBullets);
              if (found && found.parent) {
                  const parentInfo = findBulletAndParent(found.parent.id, newBullets);
                  if(parentInfo && !parentInfo.node.isReadOnly){
                      const [movedNode] = found.siblings.splice(found.index, 1);
                      movedNode.updatedAt = Date.now();
                      const subsequentSiblings = found.siblings.splice(found.index);
                      movedNode.children.push(...subsequentSiblings);

                      parentInfo.siblings.splice(parentInfo.index + 1, 0, movedNode);
                      setBullets(newBullets);
                      handleFocusChange(id);
                  }
              }
          }, [bullets, handleFocusChange, findBulletAndParent]);

          const handleFoldAll = useCallback((id, collapse) => {
              const setCollapseRecursively = (nodes) => {
                  return nodes.map(node => {
                      const newNode = { ...node };
                      if (newNode.children.length > 0) {
                          newNode.isCollapsed = collapse;
                          if (!newNode.isReadOnly) {
                              newNode.children = setCollapseRecursively(newNode.children);
                          }
                      }
                      return newNode;
                  });
              };
          
              const findAndFold = (nodes) => {
                  return nodes.map(node => {
                      if (node.id === id) {
                          const updatedNode = { ...node };
                          if(updatedNode.children.length > 0) {
                              updatedNode.isCollapsed = collapse;
                              updatedNode.children = setCollapseRecursively(updatedNode.children);
                          }
                          return updatedNode;
                      }
                      if (node.children.length > 0) {
                          return { ...node, children: findAndFold(node.children) };
                      }
                      return node;
                  });
              };
          
              setBullets(prevBullets => findAndFold(prevBullets));
          }, []);

          const handleMoveBullet = useCallback((id, direction) => {
              const foundTarget = findBulletAndParent(id, bullets);
              if (foundTarget?.node.isReadOnly) return;

              const newBullets = structuredClone(bullets);
              const found = findBulletAndParent(id, newBullets);
          
              if (!found) return;
          
              const { siblings, index } = found;
              found.node.updatedAt = Date.now();
          
              if (direction === 'up') {
                  if (index > 0) {
                      [siblings[index], siblings[index - 1]] = [siblings[index - 1], siblings[index]];
                      setBullets(newBullets);
                  }
              } else { // 'down'
                  if (index < siblings.length - 1) {
                      [siblings[index], siblings[index + 1]] = [siblings[index + 1], siblings[index]];
                      setBullets(newBullets);
                  }
              }
          }, [bullets, findBulletAndParent]);

          const handleFocusParent = useCallback((id) => {
              const currentTree = zoomedBulletId ? displayedBullets : bullets;
              const findInCurrentView = (
                  bulletId,
                  nodes,
                  parent = null
                ) => {
                  for (const node of nodes) {
                    if (node.id === bulletId) {
                      return { node, parent };
                    }
                    const found = findInCurrentView(bulletId, node.children, node);
                    if (found) return found;
                  }
                  return null;
              };
              const found = findInCurrentView(id, currentTree);
              if (found?.parent) {
                  handleFocusChange(found.parent.id);
              }
          }, [zoomedBulletId, bullets, displayedBullets, handleFocusChange]);

          const handleFocusChild = useCallback((id) => {
              const found = findBulletAndParent(id, bullets);
              if (found?.node && found.node.children.length > 0 && !found.node.isCollapsed) {
                  handleFocusChange(found.node.children[0].id, 'start');
              }
          }, [bullets, handleFocusChange, findBulletAndParent]);


          const handleExport = () => {
              const dataStr = JSON.stringify(bullets, null, 2);
              const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
              const exportFileDefaultName = 'workflowy_clone_data.json';
              const linkElement = document.createElement('a');
              linkElement.setAttribute('href', dataUri);
              linkElement.setAttribute('download', exportFileDefaultName);
              linkElement.click();
          };

          const handleImport = (data) => {
              const migratedData = migrateBullets(data);
              setBullets(migratedData);
              setZoomedBulletId(null);
              setSearchQuery('');
          };
          
          const handleAddItemToCurrentView = useCallback(() => {
              const newBullet = createNewBullet();
              if (zoomedBulletId) {
                  const newBullets = structuredClone(bullets);
                  const found = findBulletAndParent(zoomedBulletId, newBullets);
                  if (found && !found.node.isReadOnly) {
                      found.node.children.push(newBullet);
                      found.node.isCollapsed = false;
                      found.node.updatedAt = Date.now();
                      setBullets(newBullets);
                      handleFocusChange(newBullet.id);
                  }
              } else {
                  setBullets(prev => [...prev, newBullet]);
                  handleFocusChange(newBullet.id);
              }
          }, [bullets, zoomedBulletId, handleFocusChange, findBulletAndParent]);

          const handleFocusMove = useCallback((direction, position = 'end') => {
              if (!currentFocusId) {
                  if (visibleBulletIds.length > 0) {
                       handleFocusChange(visibleBulletIds[0], position);
                  }
                  return;
              }
              const currentIndex = visibleBulletIds.indexOf(currentFocusId);
              if (currentIndex === -1) return;
              let nextIndex;
              if (direction === 'down') {
                  nextIndex = currentIndex + 1;
                  if (nextIndex < visibleBulletIds.length) {
                      handleFocusChange(visibleBulletIds[nextIndex], position);
                  }
              } else { // 'up'
                  nextIndex = currentIndex - 1;
                  if (nextIndex >= 0) {
                      handleFocusChange(visibleBulletIds[nextIndex], position);
                  }
              }
          }, [currentFocusId, visibleBulletIds, handleFocusChange]);

          const handleOpenSearch = () => {
              focusBeforeModalRef.current = currentFocusId;
              setIsSearchModalOpen(true);
          };

          const handleCloseSearch = () => {
              setIsSearchModalOpen(false);
              if (focusBeforeModalRef.current) {
                  const idToRestore = focusBeforeModalRef.current;
                  handleFocusChange(idToRestore, 'start');
                  setTimeout(() => {
                      handleFocusChange(idToRestore, 'end');
                  }, 0);
                  focusBeforeModalRef.current = null;
              }
          };

          const handleTriggerLinkPopup = useCallback((bulletId, query, inputRef, selectionHandler) => {
              if (!inputRef.current) return;
              const rect = inputRef.current.getBoundingClientRect();
              setLinkSelectionHandler({ handler: selectionHandler });

              const POPUP_MAX_WIDTH_PX = 768;
              const VIEWPORT_PADDING_PX = 16;
              
              let left = rect.left + window.scrollX;
              
              if (left + POPUP_MAX_WIDTH_PX > window.innerWidth - VIEWPORT_PADDING_PX) {
                  left = window.innerWidth - POPUP_MAX_WIDTH_PX - VIEWPORT_PADDING_PX;
              }

              left = Math.max(VIEWPORT_PADDING_PX, left);

              const suggestions = !query 
                  ? flatBullets.slice(0, 50) 
                  : flatBullets.map(bullet => {
                      const lowerText = bullet.text.toLowerCase();
                      const lowerQuery = query.toLowerCase();
                      let score = 0;
                      if (lowerText.startsWith(lowerQuery)) {
                          score = 2;
                      } else if (lowerText.includes(lowerQuery)) {
                          score = 1;
                      }
                      return { ...bullet, score };
                  })
                  .filter(bullet => bullet.score > 0 && bullet.id !== bulletId) 
                  .sort((a, b) => b.score - a.score);

              setLinkPopupState({
                  isOpen: true,
                  targetId: bulletId,
                  query: query,
                  position: { top: rect.bottom + window.scrollY, left: left },
                  suggestions: suggestions.slice(0, 100), 
                  selectedIndex: 0,
              });

          }, [flatBullets]);

          const handleCloseLinkPopup = useCallback(() => {
              setLinkPopupState(prev => {
                  if (prev.isOpen) {
                      return { ...prev, isOpen: false };
                  }
                  return prev;
              });
              setLinkSelectionHandler({ handler: null });
          }, []);

          const handleLinkNavigate = useCallback((direction) => {
              if (!linkPopupState.isOpen) return;
              setLinkPopupState(prev => ({
                  ...prev,
                  selectedIndex: navigateSuggestions(prev, direction),
              }));
          }, [linkPopupState.isOpen]);
          
          const handleLinkSelect = useCallback((callback) => {
              if (!linkPopupState.isOpen || linkPopupState.suggestions.length === 0) return;
              const selectedBullet = linkPopupState.suggestions[linkPopupState.selectedIndex];
              callback(selectedBullet);
          }, [linkPopupState]);

          const handleLinkClick = useCallback((linkText) => {
              let targetBullet = null;
              const find = (nodes) => {
                  for (const node of nodes) {
                      if (node.text === linkText) {
                          targetBullet = node;
                          return true;
                      }
                      if (find(node.children)) return true;
                  }
                  return false;
              };
              find(bullets);
          
              if (targetBullet) {
                  const path = [];
                  const findPath = (nodes, currentPath) => {
                      for (const node of nodes) {
                          const newPath = [...currentPath, node];
                          if (node.id === targetBullet.id) {
                              path.push(...newPath);
                              return true;
                          }
                          if (findPath(node.children, newPath)) return true;
                      }
                      return false;
                  };
                  findPath(bullets, []);
                  
                  const parent = path.length > 1 ? path[path.length - 2] : null;
                  setZoomedBulletId(parent ? parent.id : null);
                  setTimeout(() => handleFocusChange(targetBullet.id, 'end'), 0);
              } else {
                  console.warn(`Link target not found: "${linkText}"`);
              }
          }, [bullets, handleFocusChange]);

          const handleTriggerTagPopup = useCallback((bulletId, query, inputRef, selectionHandler) => {
              if (!inputRef.current) return;
              const rect = inputRef.current.getBoundingClientRect();
              setTagSelectionHandler({ handler: selectionHandler });

              const POPUP_MAX_WIDTH_PX = 768;
              const VIEWPORT_PADDING_PX = 16;
              let left = rect.left + window.scrollX;
              
              if (left + POPUP_MAX_WIDTH_PX > window.innerWidth - VIEWPORT_PADDING_PX) {
                  left = window.innerWidth - POPUP_MAX_WIDTH_PX - VIEWPORT_PADDING_PX;
              }
              left = Math.max(VIEWPORT_PADDING_PX, left);
              
              const lowerCaseQuery = query.toLowerCase();
              const suggestions = allTags.filter(tag => tag.toLowerCase().includes(lowerCaseQuery));

              setTagPopupState({
                  isOpen: true,
                  targetId: bulletId,
                  query: query,
                  position: { top: rect.bottom + window.scrollY, left: left },
                  suggestions: suggestions.slice(0, 100),
                  selectedIndex: 0,
              });
          }, [allTags]);

          const handleCloseTagPopup = useCallback(() => {
              setTagPopupState(prev => prev.isOpen ? { ...prev, isOpen: false } : prev);
              setTagSelectionHandler({ handler: null });
          }, []);
          
          const handleTagNavigate = useCallback((direction) => {
              if (!tagPopupState.isOpen) return;
              setTagPopupState(prev => ({
                  ...prev,
                  selectedIndex: navigateSuggestions(prev, direction),
              }));
          }, [tagPopupState.isOpen]);

          const handleTagSelect = useCallback((callback) => {
              if (!tagPopupState.isOpen || tagPopupState.suggestions.length === 0) return;
              const selectedTag = tagPopupState.suggestions[tagPopupState.selectedIndex];
              callback(selectedTag);
          }, [tagPopupState]);
          
          const handleClearDatabase = async () => {
              try {
                  await db.keyValuePairs.clear();
                  alert('All data has been cleared. The application will now reload.');
                  window.location.reload();
              } catch (error) {
                  console.error('Failed to clear database:', error);
                  alert('An error occurred while trying to clear the data.');
              }
          };

          return (
              <div className="h-screen w-screen flex flex-col">
                  <Toolbar
                      onImport={handleImport}
                      onExport={handleExport}
                      breadcrumbs={breadcrumbs}
                      onBreadcrumbClick={handleZoom}
                      fileName={settings.fileName}
                      onOpenSettings={() => setIsSettingsModalOpen(true)}
                      onGoToToday={handleGoToJournal}
                      theme={theme}
                      onThemeToggle={handleThemeToggle}
                      onOpenSearch={handleOpenSearch}
                  />
                  <main className="flex-grow overflow-y-auto p-4 md:px-8 lg:px-16 xl:px-32 outline-none">
                      {displayedBullets.length > 0 ? displayedBullets.map(bullet => (
                          <div key={bullet.id}>
                              <BulletItem
                                  bullet={bullet}
                                  level={0}
                                  onUpdate={handleUpdate}
                                  onAddSibling={handleAddSibling}
                                  onDelete={handleDelete}
                                  onIndent={handleIndent}
                                  onOutdent={handleOutdent}
                                  onFocusChange={handleFocusChange}
                                  onZoom={handleZoom}
                                  onFocusMove={handleFocusMove}
                                  onFocusParent={handleFocusParent}
                                  onFocusChild={handleFocusChild}
                                  onFoldAll={handleFoldAll}
                                  onMoveBullet={handleMoveBullet}
                                  currentFocusId={currentFocusId}
                                  focusPosition={focusPosition}
                                  searchQuery={searchQuery}
                                  onLinkClick={handleLinkClick}
                                  onTriggerLinkPopup={handleTriggerLinkPopup}
                                  onCloseLinkPopup={handleCloseLinkPopup}
                                  onLinkNavigate={handleLinkNavigate}
                                  onLinkSelect={handleLinkSelect}
                                  isLinkPopupOpen={linkPopupState.isOpen}
                                  linkPopupTargetId={linkPopupState.targetId}
                                  onTriggerTagPopup={handleTriggerTagPopup}
                                  onCloseTagPopup={handleCloseTagPopup}
                                  onTagNavigate={handleTagNavigate}
                                  onTagSelect={handleTagSelect}
                                  isTagPopupOpen={tagPopupState.isOpen}
                                  tagPopupTargetId={tagPopupState.targetId}
                                  isJournalRoot={bullet.text === DAILY_LOG_ROOT_TEXT && zoomedBulletId === null}
                                  onNavigateTo={handleNavigate}
                              />
                          </div>
                      )) : (
                          <div className="flex justify-center items-center h-full text-gray-400 dark:text-gray-500">
                              <button onClick={handleAddItemToCurrentView} className="border border-dashed border-gray-300 dark:border-gray-600 px-4 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                                 {zoomedBulletId ? 'Add an item here' : 'Start with a new item'}
                              </button>
                          </div>
                      )}
                       {linkPopupState.isOpen && (
                          <LinkPopup
                              suggestions={linkPopupState.suggestions}
                              selectedIndex={linkPopupState.selectedIndex}
                              onSelect={(bullet) => {
                                  if (linkSelectionHandler.handler) {
                                      linkSelectionHandler.handler(bullet);
                                  }
                              }}
                              position={linkPopupState.position}
                              containerRef={linkPopupRef}
                          />
                      )}
                      {tagPopupState.isOpen && (
                          <TagPopup
                              suggestions={tagPopupState.suggestions}
                              selectedIndex={tagPopupState.selectedIndex}
                              onSelect={(tag) => {
                                  if (tagSelectionHandler.handler) {
                                      tagSelectionHandler.handler(tag);
                                  }
                              }}
                              position={tagPopupState.position}
                              containerRef={tagPopupRef}
                          />
                      )}
                  </main>
                  <footer className="flex-shrink-0 p-1 px-4 text-xs text-[var(--main-color)] border-t border-gray-200 dark:border-gray-700 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm flex justify-between items-center">
                      <span title={settings.fileName} className="truncate">{settings.fileName}</span>
                      <span>Version 0.1.5</span>
                  </footer>
                   <SearchModal
                      isOpen={isSearchModalOpen}
                      onClose={handleCloseSearch}
                      bullets={flatBullets}
                      onNavigate={handleNavigate}
                      allTags={allTags}
                  />
                  <SettingsModal 
                      isOpen={isSettingsModalOpen}
                      onClose={() => setIsSettingsModalOpen(false)}
                      onSave={setSettings}
                      currentSettings={settings}
                      onClearDatabase={handleClearDatabase}
                  />
              </div>
          );
      };
      // --- END: App.tsx ---


      // --- START: index.tsx ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = ReactDOM.createRoot(rootElement);
      root.render(
          <App />
      );
      // --- END: index.tsx ---
    </script>
  </body>
</html>