<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Jaroet Outliner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
      }
    </script>
    <!-- Add Babel for in-browser JSX/TS transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Add Dexie.js for IndexedDB -->
    <script src="https://unpkg.com/dexie@4.0.7/dist/dexie.js"></script>
    <!-- Configure Babel -->
    <script>
      Babel.config({
        presets: [
          // preset-env configuration:
          // target modern browsers and DO NOT transform ES6 modules (import/export).
          // The browser will handle modules via the importmap.
          ["env", { "modules": false }],
          // preset-react for JSX support
          "react",
          // preset-typescript for TypeScript support
          "typescript"
        ]
      });
    </script>
    <style>
      :root {
        --main-color: #60a5fa;
        --font-family: sans-serif;
        --font-size: 16px;
      }
      body {
        font-family: var(--font-family);
        font-size: var(--font-size);
        overflow: hidden; /* Prevent body scroll when resizing */
      }
      /* Simple scrollbar styling for a more modern look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      /* Light theme */
      ::-webkit-scrollbar-track {
        background: #f1f5f9; /* cool-gray-100 */
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; /* cool-gray-300 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; /* cool-gray-400 */
      }
      /* Dark theme */
      .dark ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
      .focus-outline {
        outline: 2px solid var(--main-color);
        outline-offset: -1px;
        border-radius: 4px;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client"
  }
}
</script>
</head>
  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 antialiased transition-colors duration-200">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
import React from 'react';
import ReactDOM from 'react-dom/client';
// All application code is bundled here to run from file://

// Dexie DB setup
class JaroetDatabase extends Dexie {
    keyValuePairs;

    constructor() {
        super("JaroetOutlinerDB");
        this.version(1).stores({
            // Store simple key-value pairs, mimicking localStorage but async
            keyValuePairs: 'key', 
        });
        this.keyValuePairs = this.table('keyValuePairs');
    }
}

const db = new JaroetDatabase();


// From components/Icons.tsx
const ChevronRightIcon = ({ className = 'w-4 h-4' }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
  </svg>
);

const ChevronDownIcon = ({ className = 'w-4 h-4' }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
  </svg>
);

const CircleIcon = ({ className = 'w-2 h-2', color = 'var(--main-color)' }) => (
  <svg viewBox="0 0 100 100" className={className}>
    <circle cx="50" cy="50" r="50" fill={color} />
  </svg>
);

const SearchIcon = ({ className = 'w-5 h-5' }) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
    <path strokeLinecap="round" strokeLinejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
  </svg>
);

const UploadIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
    </svg>
);

const DownloadIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
    </svg>
);

const HomeIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
      <path d="M11.47 3.84a.75.75 0 011.06 0l8.69 8.69a.75.75 0 101.06-1.06l-8.689-8.69a2.25 2.25 0 00-3.182 0l-8.69 8.69a.75.75 0 001.061 1.06l8.69-8.69z" />
      <path d="M12 5.432L4.432 13v6.75a2.25 2.25 0 002.25 2.25h10.636a2.25 2.25 0 002.25-2.25v-6.75L12 5.432z" />
    </svg>
);

const TagIcon = ({ className = 'w-4 h-4' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.568 3H5.25A2.25 2.25 0 0 0 3 5.25v4.318c0 .597.237 1.17.659 1.591l9.581 9.581c.699.699 1.78.872 2.607.33a18.095 18.095 0 0 0 5.223-5.223c.542-.827.369-1.908-.33-2.607L11.16 3.66A2.25 2.25 0 0 0 9.568 3Z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M6 6h.008v.008H6V6Z" />
    </svg>
);

const AppointmentIcon = ({ className = 'w-4 h-4' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18" />
    </svg>
);

const SettingsIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.242 1.41l-1.028.937c-.28.254-.434.62-.434.995s.154.74.434.995l1.028.937a1.125 1.125 0 01.242 1.41l-1.296 2.247a1.125 1.125 0 01-1.37.49l-1.217-.456c-.355-.133-.75-.072-1.075.124a6.57 6.57 0 01-.22.127c-.331.183-.581.495-.645.87l-.213 1.281c-.09.543-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.313-.686-.645-.87a6.52 6.52 0 01-.22-.127c-.324-.196-.72-.257-1.075-.124l-1.217.456a1.125 1.125 0 01-1.37-.49l-1.296-2.247a1.125 1.125 0 01.242-1.41l1.028-.937c.28-.254.434-.62.434.995s-.154-.74-.434-.995l-1.028-.937a1.125 1.125 0 01-.242-1.41l1.296-2.247a1.125 1.125 0 011.37.49l1.217.456c.355.133.75.072 1.075-.124.073-.044.146-.087.22-.127.332-.183.582-.495.645-.87l.213-1.281z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);

const CloudIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 15a4.5 4.5 0 0 0 4.5 4.5H18a3.75 3.75 0 0 0 1.332-7.257 3 3 0 0 0-3.758-3.848 5.25 5.25 0 0 0-10.233 2.33A4.5 4.5 0 0 0 2.25 15Z" />
    </svg>
);

const CheckCircleIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
    </svg>
);

const ArrowPathIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M4.5 12c0-3.75 3-6.75 6.75-6.75s6.75 3 6.75 6.75-3 6.75-6.75 6.75S4.5 15.75 4.5 12Z" />
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 4.5v.01M17.364 6.636l-.007.007M4.5 12H4m13.5 0h.01M6.636 17.364l-.007-.007M12 19.5v-.01" />
    </svg>
);

const SunIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.95-4.223-1.591 1.591M5.25 12H3m4.223-4.95-1.591-1.591M12 6a6 6 0 1 0 0 12 6 6 0 0 0 0-12Z" />
    </svg>
);

const MoonIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
        <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25c0 5.385 4.365 9.75 9.75 9.75 2.806 0 5.347-1.257 7.141-3.248a9.753 9.753 0 0 1 1.861-3.75Z" />
    </svg>
);

const SidebarLeftIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5" />
    </svg>
);

const SidebarRightIcon = ({ className = 'w-5 h-5' }) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M12.75 19.5l-7.5-7.5 7.5-7.5m-6 15l-7.5-7.5 7.5-7.5" />
    </svg>
);

// From App.tsx (constants and helpers)
const DAILY_LOG_ROOT_TEXT = 'Daily Log';
const TAGS_ROOT_TEXT = 'Tags';
const SEARCH_ROOT_TEXT = 'Search';

const initialData = [
  {
    id: 'journal-root',
    text: DAILY_LOG_ROOT_TEXT,
    children: [],
    isCollapsed: true,
  },
  {
    id: 'doc-root',
    text: 'Help & Documentation',
    children: [
      {
        id: 'changelog-root',
        text: 'Changelog',
        children: [
             {
                id: 'cl-4',
                text: new Date().toLocaleDateString() + ': Sidebar Updates',
                children: [
                    { id: 'cl-4-a', text: "Added a tags filter search field in the sidebar.", children: [], isCollapsed: false },
                    { id: 'cl-4-b', text: 'Fixed folding logic for sidebar search and tags branches when empty.', children: [], isCollapsed: false },
                    { id: 'cl-4-c', text: 'Improved keyboard navigation for sidebar inputs.', children: [], isCollapsed: false },
                ],
                isCollapsed: false
            },
            {
                id: 'cl-3',
                text: 'Sidebar Enhancements',
                children: [
                    { id: 'cl-3-a', text: "Added a search filter in the sidebar.", children: [], isCollapsed: false },
                    { id: 'cl-3-b', text: 'Improved keyboard navigation in the sidebar.', children: [], isCollapsed: false },
                ],
                isCollapsed: false
            },
            {
                id: 'cl-2',
                text: 'Bug Fixes & Optimizations',
                children: [
                    { id: 'cl-2-a', text: "Fixed a crash when expanding the 'Tags' section in the sidebar.", children: [], isCollapsed: false },
                    { id: 'cl-2-b', text: 'Refactored internal bullet addition logic for better consistency.', children: [], isCollapsed: false },
                ],
                isCollapsed: false
            },
            {
                id: 'cl-1',
                text: 'Code Refactoring & Cleanup',
                children: [
                    { id: 'cl-1-a', text: 'Removed unused color utility functions.', children: [], isCollapsed: false },
                    { id: 'cl-1-b', text: 'Upgraded object cloning to `structuredClone` for better performance.', children: [], isCollapsed: false },
                    { id: 'cl-1-c', text: 'Improved unique ID generation using `crypto.randomUUID`.', children: [], isCollapsed: false },
                    { id: 'cl-1-d', text: 'Optimized text rendering to reduce unnecessary recalculations.', children: [], isCollapsed: false },
                ],
                isCollapsed: true
            }
        ],
        isCollapsed: false
      },
      {
        id: 'gs-1',
        text: 'Quick Start Guide',
        children: [
          { id: 'gs-2', text: 'Click on an item to start typing.', children: [], isCollapsed: false },
          { id: 'gs-3', text: 'Press `Enter` to split an item or create a new one.', children: [], isCollapsed: false },
          { id: 'gs-4', text: 'Press `Shift+Enter` to create a new line within an item.', children: [], isCollapsed: false },
          { id: 'gs-5', text: 'Press `Tab` to indent an item (make it a child).', children: [], isCollapsed: false },
          { id: 'gs-6', text: 'Press `Shift+Tab` to outdent an item.', children: [], isCollapsed: false },
        ],
        isCollapsed: false,
      },
      {
        id: 'kf-1',
        text: 'Key Features',
        children: [
          { id: 'kf-2', text: "Zoom In: Click a bullet point to focus on that item and its children.", children: [], isCollapsed: false },
          { id: 'kf-3', text: 'Zoom Out: Use the breadcrumbs at the top or press `Ctrl+Up` to go back.', children: [], isCollapsed: false },
          { id: 'kf-5', text: 'Expand/Collapse: Click the triangle next to an item to show or hide its children.', children: [], isCollapsed: false },
          { id: 'kf-6', text: "Daily Log: Press `Ctrl+J` to jump directly to a special section for today's date.", children: [], isCollapsed: false },
          { id: 'kf-7', text: "Quick Find: Press `Ctrl+Shift+K` to open the search bar.", children: [], isCollapsed: false },
          { id: 'kf-8', text: "Tags: Type #tagname to create a tag. An overview of all your tags will automatically appear under the 'Tags' section in the sidebar.", children: [], isCollapsed: false },
          { id: 'kf-9', text: "Sidebar: Press `Ctrl+\\` to toggle the sidebar.", children: [], isCollapsed: false },
          { id: 'kf-10', text: "Focus: Press `Ctrl+'` to switch focus between the main outline and the sidebar.", children: [], isCollapsed: false },
        ],
        isCollapsed: false,
      },
      {
        id: 'hk-1',
        text: 'All Hotkeys',
        children: [
          { 
            id: 'hk-edit', text: 'Creating & Editing', children: [
              { id: 'hk-e-1', text: 'Enter : Create a new item or split the current one', children: [], isCollapsed: false },
              { id: 'hk-e-2', text: 'Shift+Enter : Add a new line within the current item', children: [], isCollapsed: false },
              { id: 'hk-e-3', text: 'Tab : Indent current item', children: [], isCollapsed: false },
              { id: 'hk-e-4', text: 'Shift+Tab : Outdent current item', children: [], isCollapsed: false },
              { id: 'hk-e-5', text: 'Backspace (on an empty item) : Delete the item', children: [], isCollapsed: false },
              { id: 'hk-e-6', text: 'Ctrl+L : Turn selected text into a link', children: [], isCollapsed: false },
              { id: 'hk-e-7', text: '[[ : Start typing to link to another item', children: [], isCollapsed: false },
            ],
            isCollapsed: true,
          },
          {
            id: 'hk-nav', text: 'Navigation & View', children: [
                { id: 'hk-n-1', text: 'Up/Down Arrow : Navigate between items', children: [], isCollapsed: false },
                { id: 'hk-n-2', text: 'Ctrl+Down Arrow (or click bullet) : Zoom in', children: [], isCollapsed: false },
                { id: 'hk-n-3', text: 'Ctrl+Up Arrow : Zoom out', children: [], isCollapsed: false },
                { id: 'hk-n-4', text: 'Ctrl+Left Arrow : Collapse item (if it has children) or go to parent', children: [], isCollapsed: false },
                { id: 'hk-n-5', text: 'Ctrl+Right Arrow : Expand a collapsed item', children: [], isCollapsed: false },
                { id: 'hk-n-6', text: "Ctrl+J : Go to today's log", children: [], isCollapsed: false },
                { id: 'hk-n-7', text: 'Ctrl+Shift+K : Open the "Quick Find" window', children: [], isCollapsed: false },
                { id: 'hk-n-8', text: 'Ctrl+\\ : Toggle sidebar visibility', children: [], isCollapsed: false },
                { id: 'hk-n-9', text: "Ctrl+' : Switch focus between outline and sidebar", children: [], isCollapsed: false },
            ],
            isCollapsed: true,
          },
          {
            id: 'hk-org', text: 'Organizing', children: [
                { id: 'hk-o-1', text: 'Alt+Up Arrow : Move item up', children: [], isCollapsed: false },
                { id: 'hk-o-2', text: 'Alt+Down Arrow : Move item down', children: [], isCollapsed: false },
            ],
            isCollapsed: true,
          }
        ],
        isCollapsed: false,
      }
    ],
    isCollapsed: true,
  },
];

const createNewBullet = (text = '') => ({
    id: crypto.randomUUID(),
    text,
    children: [],
    isCollapsed: false,
});


// From components/LinkPopup.tsx
const LinkPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
  const { useEffect, useRef } = React;
  const selectedItemRef = useRef(null);
  
  useEffect(() => {
    if (selectedItemRef.current) {
        selectedItemRef.current.scrollIntoView({ block: 'nearest' });
    }
  }, [selectedIndex]);

  if (suggestions.length === 0) {
    return null;
  }

  return (
    <div
      className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-full max-w-2xl"
      style={{ top: position.top, left: position.left }}
    >
      <ul ref={containerRef}>
        {suggestions.map((bullet, index) => (
          <li key={bullet.id} ref={index === selectedIndex ? selectedItemRef : null}>
            <button
              onClick={() => onSelect(bullet)}
              className={`w-full text-left px-3 py-2 text-sm ${
                index === selectedIndex ? 'bg-[var(--main-color)] text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
              }`}
               title={bullet.text}
            >
              <span className="truncate block">{bullet.text || <em>Untitled</em>}</span>
              {bullet.path.length > 0 && (
                  <span className={`text-xs truncate block ${
                    index === selectedIndex ? 'text-white/80' : 'text-gray-400 dark:text-gray-500'
                  }`}>{bullet.path.join(' / ')}</span>
              )}
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
};


// From components/SearchModal.tsx
const SearchModal = ({ isOpen, onClose, bullets, onNavigate }) => {
  const { useState, useEffect, useMemo, useRef } = React;
  const [query, setQuery] = useState('');
  const [selectedIndex, setSelectedIndex] = useState(0);
  const inputRef = useRef(null);
  const listRef = useRef(null);
  const selectedItemRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      inputRef.current?.focus();
      setQuery('');
      setSelectedIndex(0);
    }
  }, [isOpen]);

  const filteredBullets = useMemo(() => {
    if (!query) {
      return bullets;
    }
    const lowerCaseQuery = query.toLowerCase();
    return bullets.filter(b => b.text.toLowerCase().includes(lowerCaseQuery));
  }, [query, bullets]);

  useEffect(() => {
    if (selectedItemRef.current) {
      selectedItemRef.current.scrollIntoView({ block: 'nearest' });
    }
  }, [selectedIndex]);

  const handleKeyDown = (e) => {
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      setSelectedIndex(prev => (prev + 1) % filteredBullets.length);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      setSelectedIndex(prev => (prev - 1 + filteredBullets.length) % filteredBullets.length);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (filteredBullets[selectedIndex]) {
        onNavigate(filteredBullets[selectedIndex].id);
      }
    } else if (e.key === 'Escape') {
      onClose();
    }
  };

  const highlightMatch = (text, q) => {
      if (!q || !text) return text;
      const parts = text.split(new RegExp(`(${q})`, 'gi'));
      return (
          <span>
              {parts.map((part, i) => 
                  part.toLowerCase() === q.toLowerCase() ? 
                  <span key={i} className="bg-yellow-400/40 dark:bg-yellow-600/40 rounded-sm">{part}</span> : 
                  part
              )}
          </span>
      );
  };

  if (!isOpen) {
    return null;
  }

  return (
    <div
      className="fixed inset-0 bg-black/40 dark:bg-black/60 z-30 flex justify-center items-start pt-20"
      onClick={onClose}
    >
      <div
        className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[70vh] flex flex-col"
        onClick={e => e.stopPropagation()}
        onKeyDown={handleKeyDown}
      >
        <div className="p-4 border-b border-gray-200 dark:border-gray-700 relative text-[var(--main-color)]">
          <span className="absolute inset-y-0 left-0 flex items-center pl-7">
            <SearchIcon />
          </span>
          <input
            ref={inputRef}
            type="text"
            placeholder="Quick find..."
            value={query}
            onChange={e => setQuery(e.target.value)}
            className="w-full bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 pl-10 pr-4 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"
          />
        </div>
        <div className="overflow-y-auto">
          {filteredBullets.length > 0 ? (
            <ul ref={listRef}>
              {filteredBullets.map((bullet, index) => (
                <li
                  key={bullet.id}
                  ref={index === selectedIndex ? selectedItemRef : null}
                  className={`cursor-pointer transition-colors duration-75 ${index === selectedIndex ? 'bg-[var(--main-color)] text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'}`}
                  onClick={() => onNavigate(bullet.id)}
                >
                  <div className="px-4 py-2 border-b border-gray-200/50 dark:border-gray-700/50">
                    <div className={`text-sm font-medium truncate mb-1 ${index === selectedIndex ? 'text-white' : 'text-gray-800 dark:text-gray-200'}`}>
                        {highlightMatch(bullet.text, query) || <em>Untitled</em>}
                    </div>
                    <div className={`text-xs flex flex-wrap items-center gap-1 leading-none ${
                        index === selectedIndex ? 'text-blue-100' : 'text-gray-500 dark:text-gray-400'
                    }`}>
                        {bullet.path.length > 0 ? (
                            bullet.path.map((segment, i) => (
                                <React.Fragment key={i}>
                                    <span className="truncate max-w-[200px]" title={segment}>{segment}</span>
                                    {i < bullet.path.length - 1 && (
                                        <span className="opacity-50 flex-shrink-0">/</span>
                                    )}
                                </React.Fragment>
                            ))
                        ) : (
                             <span className="italic opacity-50">Top level</span>
                        )}
                    </div>
                  </div>
                </li>
              ))}
            </ul>
          ) : (
            <p className="text-gray-400 dark:text-gray-500 p-4 text-center">No results found.</p>
          )}
        </div>
      </div>
    </div>
  );
};

// From components/Toolbar.tsx
const SyncIndicator = ({ status }) => {
    switch (status) {
        case 'syncing':
            return <div title="Saving to Gist..." className="p-2 text-gray-400"><ArrowPathIcon className="animate-spin" /></div>;
        case 'synced':
            return <div title="Data saved to Gist" className="p-2 text-green-400"><CheckCircleIcon /></div>;
        case 'error':
            return <div title="Sync failed. Check console and settings." className="p-2 text-red-400"><CloudIcon /></div>;
        case 'offline':
        default:
            return <div title="Data is being saved to your local browser" className="p-2 text-gray-400"><CloudIcon /></div>;
    }
};

const Toolbar = ({
  onImport,
  onExport,
  breadcrumbs,
  onBreadcrumbClick,
  fileName,
  onOpenSettings,
  syncStatus,
  onGoToToday,
  theme,
  onThemeToggle,
  onToggleSidebar,
  isSidebarCollapsed,
}) => {
  const { useRef } = React;
  const fileInputRef = useRef(null);

  const handleImportClick = () => {
    fileInputRef.current?.click();
  };

  const handleFileChange = (event) => {
    const file = event.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const content = e.target?.result;
          const data = JSON.parse(content);
          // Basic validation
          if (Array.isArray(data) && data.every(item => 'id' in item && 'text' in item)) {
            onImport(data);
          } else {
            alert('Invalid JSON file format.');
          }
        } catch (error) {
          alert('Error parsing JSON file.');
          console.error(error);
        }
      };
      reader.readAsText(file);
    }
     // Reset file input to allow re-uploading the same file
    if(event.target) {
        event.target.value = '';
    }
  };

  return (
    <div className="flex-shrink-0 sticky top-0 z-20 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-2 flex items-center gap-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
        <div className="flex-grow flex items-center gap-2 overflow-hidden">
            <button onClick={() => onBreadcrumbClick(null)} className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <HomeIcon />
            </button>
            {breadcrumbs.map((crumb) => (
                <React.Fragment key={crumb.id}>
                <span className="text-gray-400 dark:text-gray-500">/</span>
                <button
                    onClick={() => onBreadcrumbClick(crumb.id)}
                    className="px-2 py-1 text-sm text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors truncate"
                    title={crumb.text}
                >
                    {crumb.text || <em>Untitled</em>}
                </button>
                </React.Fragment>
            ))}
            {breadcrumbs.length === 0 && (
                <span className="text-gray-800 dark:text-gray-200 font-semibold ml-2 truncate" title={fileName}>{fileName}</span>
            )}
        </div>

      <div className="flex items-center gap-2">
        <button onClick={onGoToToday} title="Go to Today's Log (Ctrl+J)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
            <AppointmentIcon className="w-5 h-5" />
        </button>

        <div className="flex items-center gap-1">
            <SyncIndicator status={syncStatus} />
            <input
                type="file"
                ref={fileInputRef}
                className="hidden"
                accept=".json"
                onChange={handleFileChange}
            />
            <button onClick={handleImportClick} title="Import from JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <UploadIcon />
            </button>
            <button onClick={onExport} title="Export to JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <DownloadIcon />
            </button>
            <button onClick={onThemeToggle} title="Toggle Theme" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                {theme === 'dark' ? <SunIcon /> : <MoonIcon />}
            </button>
            <button onClick={onOpenSettings} title="Settings" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                <SettingsIcon />
            </button>
            <button onClick={onToggleSidebar} title="Toggle Sidebar (Ctrl+\)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                {isSidebarCollapsed ? <SidebarLeftIcon /> : <SidebarRightIcon />}
            </button>
        </div>
      </div>
    </div>
  );
};


// From components/BulletItem.tsx
const BulletItem = ({
  bullet,
  level,
  onUpdate,
  onAddSibling,
  onDelete,
  onIndent,
  onOutdent,
  onFocusChange,
  onZoom,
  onFocusMove,
  onFocusParent,
  onFocusChild,
  onFoldAll,
  onMoveBullet,
  currentFocusId,
  focusPosition,
  searchQuery,
  onLinkClick,
  onTriggerLinkPopup,
  onCloseLinkPopup,
  onLinkNavigate,
  onLinkSelect,
  isLinkPopupOpen,
  linkPopupTargetId,
  isJournalRoot,
  isTagsRoot,
  onNavigateTo,
  activePanel,
}) => {
  const { useState, useRef, useEffect, useCallback, useMemo } = React;
  const [isEditing, setIsEditing] = useState(false);
  const textInputRef = useRef(null);

  const isFocused = currentFocusId === bullet.id;
  
  useEffect(() => {
    if (isFocused && activePanel === 'main') {
      setIsEditing(true);
    } else {
      setIsEditing(false);
      onCloseLinkPopup();
    }
  }, [isFocused, activePanel, onCloseLinkPopup]);

  useEffect(() => {
    if (isEditing && textInputRef.current) {
        textInputRef.current.focus();
        if (focusPosition === 'start') {
            textInputRef.current.setSelectionRange(0, 0);
        } else { // 'end'
            const len = textInputRef.current.value.length;
            textInputRef.current.setSelectionRange(len, len);
        }
    }
  }, [isEditing, focusPosition]);
    
  useEffect(() => {
    if (isEditing && textInputRef.current) {
      textInputRef.current.style.height = 'auto';
      textInputRef.current.style.height = `${textInputRef.current.scrollHeight}px`;
    }
  }, [isEditing, bullet.text]);

  const hasChildren = bullet.children.length > 0;

  const handleLinkSelection = useCallback((selectedBullet) => {
    const input = textInputRef.current;
    if (!input) return;

    const text = input.value;
    const cursor = input.selectionStart ?? text.length;
    
    const textBeforeCursor = text.substring(0, cursor);
    const lastOpen = textBeforeCursor.lastIndexOf('[[');

    if (lastOpen !== -1) {
        const newText = text.substring(0, lastOpen) + `[[${selectedBullet.text}]]` + text.substring(cursor);
        onUpdate(bullet.id, { text: newText });
        onCloseLinkPopup();

        setTimeout(() => {
            const newCursorPos = (text.substring(0, lastOpen) + `[[${selectedBullet.text}]]`).length;
            input.focus();
            input.setSelectionRange(newCursorPos, newCursorPos);
        }, 0);
    }
  }, [bullet.id, onUpdate, onCloseLinkPopup]);

  const handleTextChange = (e) => {
    const text = e.target.value;
    const cursor = e.target.selectionStart;
    onUpdate(bullet.id, { text });

    const textBeforeCursor = text.substring(0, cursor ?? 0);
    const lastOpen = textBeforeCursor.lastIndexOf('[[');
    if (lastOpen !== -1) {
      const lastClose = textBeforeCursor.lastIndexOf(']]');
      if (lastClose < lastOpen) {
        const query = textBeforeCursor.substring(lastOpen + 2);
        onTriggerLinkPopup(bullet.id, query, textInputRef, handleLinkSelection);
        return;
      }
    }
    onCloseLinkPopup();
  };

  const handleTextKeyDown = (e) => {
    const input = e.target;
    const isPopupActive = isLinkPopupOpen && linkPopupTargetId === bullet.id;
    
    if (bullet.isReadOnly) {
        let handled = true;
        if (e.ctrlKey) {
            switch (e.key) {
                case 'ArrowLeft':
                    if (hasChildren && !bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: true });
                    else if (level > 0) onFocusParent(bullet.id);
                    break;
                case 'ArrowRight':
                    if (hasChildren && bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: false });
                    break;
                case 'ArrowDown':
                    onZoom(bullet.id);
                    break;
                default:
                    handled = false;
            }
        } else {
            switch(e.key) {
                case 'Enter':
                    if (bullet.originalId) {
                        onNavigateTo(bullet.originalId);
                    } else if (hasChildren) {
                        onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed });
                    }
                    break;
                case 'ArrowUp': onFocusMove('up'); break;
                case 'ArrowDown': onFocusMove('down'); break;
                case 'ArrowLeft': onFocusParent(bullet.id); break;
                case 'ArrowRight': 
                    if(hasChildren && !bullet.isCollapsed) onFocusChild(bullet.id);
                    else onFocusMove('down', 'start'); 
                    break;
                default: handled = false;
            }
        }

        if (handled) {
            e.preventDefault();
        }
        return;
    }

    if (isPopupActive) {
        let handled = true;
        switch (e.key) {
            case 'ArrowUp': onLinkNavigate('up'); break;
            case 'ArrowDown': onLinkNavigate('down'); break;
            case 'Enter': onLinkSelect(handleLinkSelection); break;
            case 'Tab': onLinkSelect(handleLinkSelection); break;
            case 'Escape': {
                onCloseLinkPopup();
                const text = input.value;
                const cursor = input.selectionStart ?? text.length;
                const textBeforeCursor = text.substring(0, cursor);
                const lastOpen = textBeforeCursor.lastIndexOf('[[');
                if (lastOpen !== -1 && textBeforeCursor.lastIndexOf(']]') < lastOpen) {
                    const newText = text.substring(0, lastOpen) + text.substring(cursor);
                    onUpdate(bullet.id, { text: newText });
                    setTimeout(() => {
                        if(textInputRef.current) {
                            textInputRef.current.focus();
                            textInputRef.current.setSelectionRange(lastOpen, lastOpen);
                        }
                    }, 0);
                }
                break;
            }
            default: handled = false;
        }
        if (handled) { e.preventDefault(); return; }
    }

    if (e.ctrlKey && (e.key === 'l' || e.key === 'L')) {
        e.preventDefault();
        const start = input.selectionStart;
        const end = input.selectionEnd;
        const text = input.value;
        const selectedText = text.substring(start, end);

        let newText;
        let newCursorPosStart;
        let newCursorPosEnd;

        if (selectedText) {
            newText = `${text.substring(0, start)}[${selectedText}]()${text.substring(end)}`;
            newCursorPosStart = newCursorPosEnd = start + selectedText.length + 3;
        } else {
            newText = `${text.substring(0, start)}[link text]()${text.substring(end)}`;
            newCursorPosStart = start + 1;
            newCursorPosEnd = start + 1 + 'link text'.length;
        }

        onUpdate(bullet.id, { text: newText });

        setTimeout(() => {
            if (textInputRef.current) {
                textInputRef.current.focus();
                textInputRef.current.setSelectionRange(newCursorPosStart, newCursorPosEnd);
            }
        }, 0);
        return;
    }


    if (e.altKey) {
        if (e.key === 'ArrowUp') { e.preventDefault(); onMoveBullet(bullet.id, 'up'); return; }
        if (e.key === 'ArrowDown') { e.preventDefault(); onMoveBullet(bullet.id, 'down'); return; }
    }

    if (e.ctrlKey && e.shiftKey) {
        if (e.key === 'ArrowLeft') { e.preventDefault(); onFoldAll(bullet.id, true); return; }
        if (e.key === 'ArrowRight') { e.preventDefault(); onFoldAll(bullet.id, false); return; }
    }

    if (e.ctrlKey) {
        let handled = true;
        switch (e.key) {
            case 'ArrowLeft':
                if (hasChildren && !bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: true });
                else if (level > 0) onFocusParent(bullet.id);
                break;
            case 'ArrowRight':
                if (hasChildren && bullet.isCollapsed) onUpdate(bullet.id, { isCollapsed: false });
                else if (hasChildren && !bullet.isCollapsed) onFocusChild(bullet.id);
                break;
            case 'ArrowDown': onZoom(bullet.id); break;
            default: handled = false;
        }
        if (handled) { e.preventDefault(); return; }
    }

    switch (e.key) {
      case 'Enter':
        e.preventDefault();
        if (e.shiftKey) {
            const { value, selectionStart, selectionEnd } = input;
            const newValue = value.substring(0, selectionStart) + '\n' + value.substring(selectionEnd);
            onUpdate(bullet.id, { text: newValue });

            setTimeout(() => {
                if (textInputRef.current) {
                    const newCursorPos = selectionStart + 1;
                    textInputRef.current.focus();
                    textInputRef.current.setSelectionRange(newCursorPos, newCursorPos);
                }
            }, 0);
        } else {
            const { value, selectionStart } = input;
            const textBeforeCursor = value.substring(0, selectionStart);
            const textAfterCursor = value.substring(selectionStart);
            
            onUpdate(bullet.id, { text: textBeforeCursor });
            onAddSibling(bullet.id, textAfterCursor);
        }
        break;
      case 'Tab':
        e.preventDefault();
        if (e.shiftKey) onOutdent(bullet.id);
        else onIndent(bullet.id);
        break;
      case 'Backspace':
        if (bullet.text === '') {
          e.preventDefault();
          onDelete(bullet.id);
        }
        break;
      case 'ArrowUp': e.preventDefault(); onFocusMove('up'); break;
      case 'ArrowDown': e.preventDefault(); onFocusMove('down'); break;
      case 'ArrowLeft':
        if (input.selectionStart === 0) { e.preventDefault(); onFocusParent(bullet.id); }
        break;
      case 'ArrowRight':
        if (input.selectionStart === input.value.length) { e.preventDefault(); onFocusMove('down', 'start'); }
        break;
    }
  };

  const toggleCollapse = () => {
    if (hasChildren) {
      onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed });
    }
  };

  const matchesSearch = (b, q) => {
      if (!q) return true;
      const query = q.toLowerCase();
      const textMatch = b.text.toLowerCase().includes(query);
      const childrenMatch = b.children.some(child => matchesSearch(child, q));
      return textMatch || childrenMatch;
  };

  const highlightText = (text, highlight) => {
    if (!text) return text;
    const regex = highlight ? new RegExp(`(${highlight})`, 'gi') : null;
    const parts = highlight ? text.split(regex) : [text];
    
    return (
      <React.Fragment>
        {parts.map((part, i) => {
            if (!part) return null;
            const lines = part.split('\n');
            const partWithBreaks = lines.map((line, j) => (
                <React.Fragment key={j}>
                    {line}
                    {j < lines.length - 1 && <br />}
                </React.Fragment>
            ));

            if (highlight && part.toLowerCase() === highlight.toLowerCase()) {
                return (
                    <span key={i} className="bg-yellow-300/80 dark:bg-yellow-500/50 text-black dark:text-white rounded-sm">
                        {partWithBreaks}
                    </span>
                );
            }
            return <React.Fragment key={i}>{partWithBreaks}</React.Fragment>;
        })}
      </React.Fragment>
    );
  };

  const renderedRichText = useMemo(() => {
    const text = bullet.text;
    const highlight = searchQuery;
    const options = { internalLinks: true, renderTagsOnly: false };
    
    if (options.renderTagsOnly) {
        const tagRegex = /(#\w+)/g;
        const parts = text.split(tagRegex);
        return (
            <React.Fragment>
                {parts.map((part, index) => {
                    if (part.startsWith('#') && /#\w+/.test(part)) {
                        return (
                            <span key={index} className="bg-teal-400/20 text-teal-300 rounded-md px-1 py-0.5 mx-px text-sm">
                                {part}
                            </span>
                        );
                    }
                    return <span key={index}>{part}</span>;
                })}
            </React.Fragment>
        );
    }

    const combinedRegex = /(#\w+|\[\[.*?\]\]|\[[^\]]+?\]\([^)]+?\)|\b(?:https?|ftp):\/\/[^\s/$.?#].[^\s]*|\bwww\.[^\s/$.?#].[^\s]*|[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g;
    const parts = text.split(combinedRegex);

    return (
      <React.Fragment>
        {parts.map((part, index) => {
            if (!part) return null;
            
            if (part.startsWith('#') && /#\w+/.test(part)) {
                return (
                    <span key={index} className="bg-teal-400/20 text-teal-300 rounded-md px-1 py-0.5 mx-px text-sm">
                         {highlightText(part, highlight)}
                    </span>
                );
            }

            if (options.internalLinks && part.startsWith('[[') && part.endsWith(']]')) {
                const linkText = part.slice(2, -2);
                return (
                    <button key={index} onClick={() => onLinkClick(linkText)} className="bg-[var(--main-color)]/20 hover:bg-[var(--main-color)]/30 text-[var(--main-color)] rounded-sm px-1 py-0 mx-px transition-colors" title={`Go to: ${linkText}`}>
                        {highlightText(linkText, highlight)}
                    </button>
                );
            }
            
            const mdLinkMatch = part.match(/^\[([^\]]+)\]\(([^)]+)\)$/);
            if (mdLinkMatch) {
                const [, text, url] = mdLinkMatch;
                let href = url.trim();
                if (!/^(https?|ftp|mailto):/i.test(href)) {
                   href = `https://${href}`;
                }
                return (
                    <a key={index} href={href} target="_blank" rel="noopener noreferrer" title={`Opens: ${href}`} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">
                       {highlightText(text, highlight)}
                    </a>
                );
            }

            if (/^(https?|ftp):\/\//.test(part) || part.startsWith('www.')) {
                const href = part.startsWith('www.') ? `https://${part}` : part;
                return (
                    <a key={index} href={href} target="_blank" rel="noopener noreferrer" title={`Opens: ${href}`} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">
                        {highlightText(part, highlight)}
                    </a>
                );
            }

            if (/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(part)) {
                return (
                    <a key={index} href={`mailto:${part}`} title={`Email: ${part}`} className="text-[var(--main-color)] underline decoration-dotted hover:decoration-solid">
                        {highlightText(part, highlight)}
                    </a>
                );
            }

            return highlightText(part, highlight);
        })}
      </React.Fragment>
    );
  }, [bullet.text, searchQuery, onLinkClick]);
  
  // For the hidden overlay to match textarea
  const renderedRichTextSimple = useMemo(() => {
        const text = bullet.text;
        const tagRegex = /(#\w+)/g;
        const parts = text.split(tagRegex);
        return (
            <React.Fragment>
                {parts.map((part, index) => {
                    if (part.startsWith('#') && /#\w+/.test(part)) {
                        return (
                            <span key={index} className="bg-teal-400/20 text-teal-300 rounded-md px-1 py-0.5 mx-px text-sm">
                                {part}
                            </span>
                        );
                    }
                    return <span key={index}>{part}</span>;
                })}
            </React.Fragment>
        );
  }, [bullet.text]);

  if (searchQuery && !matchesSearch(bullet, searchQuery)) {
      return null;
  }

  const circleColor = 'var(--main-color)';
  
  const handleTextClick = () => {
    if (bullet.isReadOnly) {
        if (bullet.originalId) {
            onNavigateTo(bullet.originalId);
        } else {
            onFocusChange(bullet.id);
        }
    } else {
        onFocusChange(bullet.id);
    }
  };

  const renderBulletIcon = () => {
    if (isJournalRoot) return <AppointmentIcon className="w-4 h-4" />;
    if (isTagsRoot) return <TagIcon className="w-4 h-4" />;
    return <CircleIcon className="w-2 h-2" color={circleColor} />;
  }

  return (
    <div className="flex flex-col group">
        <div className={`flex items-start py-1 relative ${isFocused && activePanel === 'main' ? 'bg-blue-100 dark:bg-gray-800/[.6] rounded' : ''}`}>
            <div
                style={{ marginLeft: `${level * 1.5}rem` }}
                className="flex-shrink-0 flex items-center h-6 text-[var(--main-color)]"
            >
                <button
                    onClick={toggleCollapse}
                    className={`transition-opacity duration-150 text-gray-400 dark:text-gray-500 hover:text-gray-600 dark:hover:text-gray-300 ${hasChildren ? 'opacity-100 cursor-pointer' : 'opacity-0 cursor-default'}`}
                    aria-label={bullet.isCollapsed ? 'Expand' : 'Collapse'}
                >
                    {bullet.isCollapsed ? <ChevronRightIcon /> : <ChevronDownIcon />}
                </button>
                <button onClick={() => onZoom(bullet.id)} className="ml-1 w-6 h-6 flex items-center justify-center transition-colors" aria-label="Zoom in">
                    {renderBulletIcon()}
                </button>
            </div>
            <div className="flex-grow ml-2">
                <div className="flex items-center">
                    <div className="flex-grow">
                        {isEditing ? (
                            <div className="relative">
                                <div
                                    className="absolute top-0 left-0 w-full h-full pointer-events-none leading-6 whitespace-pre-wrap break-words"
                                    aria-label="true"
                                >
                                    {renderedRichTextSimple}
                                </div>
                                <textarea
                                    ref={textInputRef}
                                    value={bullet.text}
                                    onChange={handleTextChange}
                                    onKeyDown={handleTextKeyDown}
                                    readOnly={bullet.isReadOnly}
                                    className="w-full bg-transparent outline-none text-transparent caret-gray-800 dark:caret-gray-200 resize-none overflow-hidden leading-6"
                                    rows={1}
                                    aria-label="Edit item"
                                />
                            </div>
                        ) : (
                            <div onClick={handleTextClick} className={`w-full min-h-[1.5rem] leading-6 break-words ${bullet.isReadOnly ? 'cursor-text' : ''}`}>
                            {bullet.text ? renderedRichText : <span className="text-gray-400 dark:text-gray-500">...</span>}
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
      {!bullet.isCollapsed && hasChildren && (
        <div className="border-l border-gray-300 dark:border-gray-700/50">
          {bullet.children.map((child) => (
            <BulletItem
                key={child.id}
                bullet={child}
                level={level + 1}
                onUpdate={onUpdate}
                onAddSibling={onAddSibling}
                onDelete={onDelete}
                onIndent={onIndent}
                onOutdent={onOutdent}
                onFocusChange={onFocusChange}
                onZoom={onZoom}
                onFocusMove={onFocusMove}
                onFocusParent={onFocusParent}
                onFocusChild={onFocusChild}
                onFoldAll={onFoldAll}
                onMoveBullet={onMoveBullet}
                currentFocusId={currentFocusId}
                focusPosition={focusPosition}
                searchQuery={searchQuery}
                onLinkClick={onLinkClick}
                onTriggerLinkPopup={onTriggerLinkPopup}
                onCloseLinkPopup={onCloseLinkPopup}
                onLinkNavigate={onLinkNavigate}
                onLinkSelect={onLinkSelect}
                isLinkPopupOpen={isLinkPopupOpen}
                linkPopupTargetId={linkPopupTargetId}
                isJournalRoot={false}
                isTagsRoot={false}
                onNavigateTo={onNavigateTo}
                activePanel={activePanel}
            />
          ))}
        </div>
      )}
    </div>
  );
};


// --- Sidebar Components ---
const SidebarItem = ({ bullet, onUpdate, onNavigateTo, level = 0, sidebarFocusId, activePanel, onFocus, middleContent }) => {
    const { useRef, useEffect } = React;
    const itemRef = useRef(null);
    const hasChildren = bullet.children && bullet.children.length > 0;
    const isFocused = sidebarFocusId === bullet.id && activePanel === 'sidebar';
    const isSearchRoot = bullet.id === 'sidebar-search-root';
    const isTagsRoot = bullet.id === 'tags-root';

    useEffect(() => {
        if (isFocused && itemRef.current) {
            itemRef.current.focus({ preventScroll: true });
            itemRef.current.scrollIntoView({ block: 'nearest', inline: 'start' });
        }
    }, [isFocused]);
    
    const handleClick = (e) => {
        e.stopPropagation();
        onFocus(bullet.id);
        if (bullet.originalId) {
            onNavigateTo(bullet.originalId);
        } else if (hasChildren || isSearchRoot || isTagsRoot) {
            onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed });
        }
    };
    
    const toggleCollapse = (e) => {
        e.stopPropagation();
        onFocus(bullet.id);
        if(hasChildren || isSearchRoot || isTagsRoot) {
            onUpdate(bullet.id, { isCollapsed: !bullet.isCollapsed });
        }
    }

    const renderIcon = () => {
        if (bullet.text === SEARCH_ROOT_TEXT) return <SearchIcon className="w-3.5 h-3.5" />;
        if (bullet.text === TAGS_ROOT_TEXT) return <TagIcon className="w-3.5 h-3.5" />;
        return <CircleIcon className="w-1.5 h-1.5" />;
    };

    return (
        <div>
            <div 
                ref={itemRef}
                tabIndex={-1}
                role="button"
                aria-label={bullet.text}
                className={`flex items-center p-1 rounded-md text-sm cursor-pointer outline-none ${isFocused ? 'bg-gray-700' : 'hover:bg-gray-700/50'}`}
                style={{ paddingLeft: `${level * 1 + 0.25}rem` }}
                onClick={handleClick}
            >
                <button
                    onClick={toggleCollapse}
                    className={`flex-shrink-0 transition-opacity duration-150 text-gray-500 hover:text-gray-300 ${hasChildren || isSearchRoot || isTagsRoot ? 'opacity-100' : 'opacity-0'}`}
                    aria-label={bullet.isCollapsed ? "Expand" : "Collapse"}
                >
                    {bullet.isCollapsed ? <ChevronRightIcon className="w-3 h-3"/> : <ChevronDownIcon className="w-3 h-3"/>}
                </button>
                 <div className="ml-2 w-4 h-4 flex items-center justify-center">{renderIcon()}</div>
                <span className="ml-2 truncate flex-grow" title={bullet.text}>{bullet.text}</span>
            </div>
            {!bullet.isCollapsed && (
                <div>
                    {middleContent}
                    {bullet.children.map(child => (
                        <SidebarItem
                            key={child.id}
                            bullet={child}
                            onUpdate={onUpdate}
                            onNavigateTo={onNavigateTo}
                            level={level + 1}
                            sidebarFocusId={sidebarFocusId}
                            activePanel={activePanel}
                            onFocus={onFocus}
                            middleContent={null}
                        />
                    ))}
                </div>
            )}
        </div>
    );
};

const Sidebar = ({
    sidebarTree,
    onSidebarUpdate,
    onNavigateTo,
    sidebarFocusId,
    activePanel,
    sidebarSearchQuery,
    onSearchQueryChange,
    sidebarTagsSearchQuery,
    onTagsSearchQueryChange,
    onSidebarKeyDown,
    onSidebarFocus,
}) => {
    const sidebarRef = React.useRef(null);
    const searchInputRef = React.useRef(null);
    const tagsSearchInputRef = React.useRef(null);
    const isSearchFocused = sidebarFocusId === 'sidebar-search-input';
    const isTagsSearchFocused = sidebarFocusId === 'sidebar-tags-search-input';

    React.useEffect(() => {
        if (activePanel === 'sidebar' && sidebarRef.current && !sidebarFocusId) {
            sidebarRef.current.focus();
        }
    }, [activePanel, sidebarFocusId]);
    
    React.useEffect(() => {
        if(isSearchFocused && searchInputRef.current) {
            searchInputRef.current.focus();
        }
    }, [isSearchFocused]);

    React.useEffect(() => {
        if(isTagsSearchFocused && tagsSearchInputRef.current) {
            tagsSearchInputRef.current.focus();
        }
    }, [isTagsSearchFocused]);

    const renderSearchInput = () => (
        <div className="pl-5 pt-2 pb-2">
            <div className={`relative text-gray-400 focus-within:text-[var(--main-color)] ${isSearchFocused ? 'ring-1 ring-[var(--main-color)] rounded-md' : ''}`}>
                <span className="absolute inset-y-0 left-0 flex items-center pl-2">
                    <SearchIcon className="w-3.5 h-3.5" />
                </span>
                <input
                    ref={searchInputRef}
                    id="sidebar-search-input"
                    type="text"
                    placeholder="Search all items..."
                    value={sidebarSearchQuery}
                    onChange={(e) => onSearchQueryChange(e.target.value)}
                    onFocus={() => onSidebarFocus('sidebar-search-input')}
                    className="w-full bg-gray-900/50 text-gray-200 text-sm pl-7 pr-2 py-1 rounded-md focus:outline-none"
                />
            </div>
        </div>
    );

    const renderTagsSearchInput = () => (
        <div className="pl-5 pt-2 pb-2">
            <div className={`relative text-gray-400 focus-within:text-[var(--main-color)] ${isTagsSearchFocused ? 'ring-1 ring-[var(--main-color)] rounded-md' : ''}`}>
                <span className="absolute inset-y-0 left-0 flex items-center pl-2">
                    <SearchIcon className="w-3.5 h-3.5" />
                </span>
                <input
                    ref={tagsSearchInputRef}
                    id="sidebar-tags-search-input"
                    type="text"
                    placeholder="Filter tags..."
                    value={sidebarTagsSearchQuery}
                    onChange={(e) => onTagsSearchQueryChange(e.target.value)}
                    onFocus={() => onSidebarFocus('sidebar-tags-search-input')}
                    className="w-full bg-gray-900/50 text-gray-200 text-sm pl-7 pr-2 py-1 rounded-md focus:outline-none"
                />
            </div>
        </div>
    );

    return (
        <aside
            ref={sidebarRef}
            tabIndex={-1}
            onKeyDown={onSidebarKeyDown}
            className={`bg-gray-800/50 dark:bg-slate-900/70 p-2 flex flex-col h-full text-gray-200 outline-none ${activePanel === 'sidebar' ? 'focus-outline' : ''}`}
        >
            <div className="flex-grow overflow-y-auto">
                {sidebarTree.map(bullet => (
                    <div key={bullet.id} className="mb-2">
                        <SidebarItem
                            bullet={bullet}
                            onUpdate={onSidebarUpdate}
                            onNavigateTo={onNavigateTo}
                            sidebarFocusId={sidebarFocusId}
                            activePanel={activePanel}
                            onFocus={onSidebarFocus}
                            middleContent={
                                bullet.id === 'sidebar-search-root' ? renderSearchInput() :
                                bullet.id === 'tags-root' ? renderTagsSearchInput() : null
                            }
                        />
                    </div>
                ))}
            </div>
        </aside>
    );
};

const Resizer = ({ onMouseDown }) => {
    return (
        <div
            className="flex-shrink-0 w-1.5 cursor-col-resize hover:bg-[var(--main-color)] transition-colors duration-200"
            onMouseDown={onMouseDown}
        />
    );
};


// --- Main App Component ---
const FONT_LIST = [
  'Arial', 'Verdana', 'Helvetica', 'Tahoma', 'Trebuchet MS', 
  'Times New Roman', 'Georgia', 'Garamond', 
  'Courier New', 'Brush Script MT', 'sans-serif', 'serif', 'monospace'
];

const GIST_FILENAME = 'JaroetOutliner-v1.json';
const GIST_DESCRIPTION = 'Jaroet Outliner Application Data';
const GITHUB_API_URL = 'https://api.github.com';

const SettingsModal = ({ isOpen, onClose, onSave, currentSettings }) => {
    const { useState, useEffect } = React;
    const [settings, setSettings] = useState(currentSettings);

    useEffect(() => {
        setSettings(currentSettings);
    }, [isOpen, currentSettings]);

    const handleSave = () => {
        onSave(settings);
        onClose();
    };
    
    const handleInputChange = (e) => {
        const { name, value } = e.target;
        setSettings(prev => ({...prev, [name]: value }));
    };

    const handleFontSizeChange = (e) => {
        setSettings(prev => ({...prev, fontSize: parseInt(e.target.value, 10) }));
    }

    if (!isOpen) return null;

    return (
        <div className="fixed inset-0 bg-black/60 z-30 flex justify-center items-center" onClick={onClose}>
            <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md" onClick={e => e.stopPropagation()}>
                <h2 className="p-4 text-lg font-semibold border-b border-gray-200 dark:border-gray-700">Settings</h2>
                <div className="p-4 space-y-4">
                    <div>
                        <label htmlFor="fileName" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">File Name</label>
                        <input type="text" id="fileName" name="fileName" value={settings.fileName} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"/>
                    </div>
                    <div>
                        <label htmlFor="mainColor" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Main Color</label>
                        <input type="color" id="mainColor" name="mainColor" value={settings.mainColor} onChange={handleInputChange} className="w-full h-10 p-1 bg-gray-100 dark:bg-gray-700 rounded-md cursor-pointer"/>
                    </div>
                    <div>
                        <label htmlFor="fontFamily" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font</label>
                        <select id="fontFamily" name="fontFamily" value={settings.fontFamily} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]">
                            {FONT_LIST.map(font => <option key={font} value={font}>{font}</option>)}
                        </select>
                    </div>
                    <div>
                        <label htmlFor="fontSize" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font Size ({settings.fontSize}px)</label>
                        <input type="range" id="fontSize" name="fontSize" min="12" max="24" value={settings.fontSize} onChange={handleFontSizeChange} className="w-full"/>
                    </div>
                    <div className="border-t border-gray-200 dark:border-gray-700 pt-4">
                        <h3 className="text-md font-semibold mb-2">GitHub Sync</h3>
                         <div>
                            <label htmlFor="githubPat" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Personal Access Token</label>
                            <input type="password" id="githubPat" name="githubPat" value={settings.githubPat} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]" placeholder="ghp_..."/>
                            <p className="text-xs text-gray-400 dark:text-gray-500 mt-1">
                                Requires <code className="bg-gray-200 dark:bg-gray-900 px-1 rounded-sm text-xs">gist</code> scope. Your token is stored locally.
                                <a href={`https://github.com/settings/tokens/new?scopes=gist&description=${encodeURIComponent(GIST_DESCRIPTION)}`} target="_blank" rel="noopener noreferrer" className="text-[var(--main-color)] underline ml-2">Create one</a>
                            </p>
                        </div>
                        <div className="mt-2">
                            <label htmlFor="gistId" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Gist ID (auto-managed)</label>
                            <input type="text" id="gistId" name="gistId" value={settings.gistId} readOnly disabled className="w-full bg-gray-200 dark:bg-gray-900 text-gray-400 dark:text-gray-500 px-3 py-2 rounded-md cursor-not-allowed"/>
                        </div>
                    </div>
                </div>
                <div className="p-4 flex justify-end gap-2 border-t border-gray-200 dark:border-gray-700">
                    <button onClick={onClose} className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white">Cancel</button>
                    <button onClick={handleSave} className="px-4 py-2 rounded-md bg-[var(--main-color)] text-white hover:opacity-90">Save</button>
                </div>
            </div>
        </div>
    );
}

const App = () => {
    const { useState, useEffect, useCallback, useMemo, useRef } = React;
    const [bullets, setBullets] = useState(initialData);
    const [zoomedBulletId, setZoomedBulletId] = useState(null);
    const [searchQuery, setSearchQuery] = useState('');
    const [focusOptions, setFocusOptions] = useState({ id: null, position: 'end' });
    const isInitialFocusSet = useRef(false);
    const linkPopupRef = useRef(null);
    const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
    const [linkSelectionHandler, setLinkSelectionHandler] = useState({ handler: null });
    const prevFocusId = useRef(null);
    const dataLoadedRef = useRef(false);
    const saveTimeoutRef = useRef(null);
    const prevCoreDataRef = useRef(null);
    const [theme, setTheme] = useState('dark');
    
    const [syncStatus, setSyncStatus] = useState('offline');
    
    const [settings, setSettings] = useState({
        mainColor: '#60a5fa',
        fileName: 'My Outline',
        fontFamily: 'sans-serif',
        fontSize: 16,
        githubPat: '',
        gistId: '',
    });
    const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);

    // Sidebar state
    const [sidebarWidth, setSidebarWidth] = useState(280);
    const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(true);
    const [isResizing, setIsResizing] = useState(false);
    const [sidebarSearchQuery, setSidebarSearchQuery] = useState('');
    const [sidebarTagsSearchQuery, setSidebarTagsSearchQuery] = useState('');
    const [sidebarTree, setSidebarTree] = useState([]);

    // Focus management state
    const [activePanel, setActivePanel] = useState('main');
    const [sidebarFocusId, setSidebarFocusId] = useState(null);

    const [linkPopupState, setLinkPopupState] = useState({
        isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0
    });

    const currentFocusId = focusOptions.id;
    const focusPosition = focusOptions.position;

    const handleFocusChange = useCallback((id, position = 'end') => {
        setFocusOptions({ id, position });
        if (id) {
            setActivePanel('main');
        }
    }, []);

    const handleSidebarFocus = useCallback((id) => {
        setSidebarFocusId(id);
        setActivePanel('sidebar');
    }, []);

    const getCoreDataString = useCallback((nodes) => {
        const removeUiState = (b) => {
            const { isCollapsed, ...coreBullet } = b;
            return {
                ...coreBullet,
                children: coreBullet.children.map(removeUiState),
            };
        };
        const coreBullets = nodes.map(removeUiState);
        return JSON.stringify(coreBullets);
    }, []);

    const handleThemeToggle = useCallback(() => {
        const newTheme = theme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        db.keyValuePairs.put({ key: 'theme', value: newTheme });
    }, [theme]);

    useEffect(() => {
        const root = window.document.documentElement;
        const isDark = theme === 'dark';
        root.classList.toggle('dark', isDark);
    }, [theme]);

    // Load settings and data on initial mount
    useEffect(() => {
        const loadData = async () => {
            // Load theme first to prevent flash of wrong theme
            const savedThemeEntry = await db.keyValuePairs.get('theme');
            const savedTheme = savedThemeEntry?.value;
            if (savedTheme && (savedTheme === 'light' || savedTheme === 'dark')) {
                setTheme(savedTheme);
            }
            
            // Load sidebar state
            const savedSidebarState = await db.keyValuePairs.get('sidebarState');
            if (savedSidebarState?.value) {
                setSidebarWidth(savedSidebarState.value.width || 280);
                setIsSidebarCollapsed(savedSidebarState.value.isCollapsed ?? true);
            }

            let loadedSettings;
            const defaultSettings = {
                mainColor: '#60a5fa',
                fileName: 'My Outline',
                fontFamily: 'sans-serif',
                fontSize: 16,
                githubPat: '',
                gistId: '',
            };
            try {
                const savedSettingsEntry = await db.keyValuePairs.get('settings');
                const savedSettings = savedSettingsEntry?.value;
                loadedSettings = { ...defaultSettings, ...(savedSettings || {}) };
                setSettings(loadedSettings);
            } catch (error) {
                console.error("Failed to load settings from IndexedDB", error);
                loadedSettings = defaultSettings;
            }

            // Always try loading from local DB first as a baseline.
            let localBullets = null;
            try {
                const savedDataEntry = await db.keyValuePairs.get('bullets');
                const savedData = savedDataEntry?.value;
                if (savedData && Array.isArray(savedData)) {
                   localBullets = savedData;
                }
            } catch(e) {
               console.error("Failed to parse local data from IndexedDB", e);
            }
            
            let initialLoadData = localBullets || initialData;
            
            setBullets(initialLoadData);
            prevCoreDataRef.current = getCoreDataString(initialLoadData);
    
            const getHeaders = (token) => ({
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
            });
    
            if (loadedSettings.githubPat) {
                setSyncStatus('syncing');
                try {
                    let gistId = loadedSettings.gistId;
                    let gist;

                    if (gistId) {
                        const response = await fetch(`${GITHUB_API_URL}/gists/${gistId}`, { 
                            headers: getHeaders(loadedSettings.githubPat),
                            cache: 'no-cache'
                        });
                        if (response.ok) {
                            gist = await response.json();
                        } else if (response.status === 404) {
                            console.warn("Gist ID not found, searching for it...");
                            gistId = ''; 
                        } else {
                            throw new Error(`GitHub API error: ${response.statusText}`);
                        }
                    }

                    if (!gistId) {
                        const response = await fetch(`${GITHUB_API_URL}/gists`, { 
                            headers: getHeaders(loadedSettings.githubPat),
                            cache: 'no-cache'
                        });
                        if (!response.ok) throw new Error(`GitHub API error: ${response.statusText}`);
                        const gists = await response.json();
                        const foundGist = gists.find(g => g.description === GIST_DESCRIPTION && g.files[GIST_FILENAME]);
                        if (foundGist) {
                            gist = foundGist;
                            gistId = foundGist.id;
                        }
                    }

                    if (gist) {
                        const fileContent = gist.files[GIST_FILENAME]?.content;
                        let gistData;
                        try {
                            gistData = JSON.parse(fileContent || '[]');
                        } catch (e) {
                            console.error("Failed to parse Gist content", e);
                            gistData = null; // Mark as failed parse
                        }
                        
                        if (Array.isArray(gistData)) {
                            if (gistData.length > 0) {
                                setBullets(gistData);
                                prevCoreDataRef.current = getCoreDataString(gistData);
                            } else {
                                console.log("Gist is empty. Preserving local data.");
                            }
                        }
                        
                        if (settings.gistId !== gist.id) {
                            setSettings(s => ({ ...s, gistId: gist.id }));
                        }

                    } else {
                        console.log("No Gist found, creating a new one...");
                        const content = JSON.stringify(initialLoadData);
                        
                        const response = await fetch(`${GITHUB_API_URL}/gists`, {
                            method: 'POST',
                            headers: getHeaders(loadedSettings.githubPat),
                            body: JSON.stringify({
                                description: GIST_DESCRIPTION,
                                public: false,
                                files: { [GIST_FILENAME]: { content } }
                            })
                        });
                        const newGist = await response.json();
                        if (!response.ok) throw new Error(newGist.message || "Failed to create Gist");
                        
                        setSettings(s => ({ ...s, gistId: newGist.id }));
                    }
                    setSyncStatus('synced');
                } catch (error) {
                    console.error("Failed to sync with GitHub Gist:", error);
                    setSyncStatus('error');
                }
            } else {
                setSyncStatus('offline');
            }
            
            setZoomedBulletId(null);
            isInitialFocusSet.current = false;
            dataLoadedRef.current = true;
        };

        loadData();
    }, [getCoreDataString]);

    // Save settings and data
    useEffect(() => {
        if (!dataLoadedRef.current) return;
        // Always save settings locally to IndexedDB
        db.keyValuePairs.put({ key: 'settings', value: settings });
        db.keyValuePairs.put({ key: 'sidebarState', value: { width: sidebarWidth, isCollapsed: isSidebarCollapsed }});
        
        document.title = `${settings.fileName || 'Untitled'} - Jaroet Outliner`;
        
        const root = document.documentElement;
        root.style.setProperty('--main-color', settings.mainColor);
        root.style.setProperty('--font-family', settings.fontFamily);
        root.style.setProperty('--font-size', `${settings.fontSize}px`);
        
        // Save main bullet data to IndexedDB
        db.keyValuePairs.put({ key: 'bullets', value: bullets });
        
        const currentCoreData = getCoreDataString(bullets);
        const hasCoreDataChanged = currentCoreData !== prevCoreDataRef.current;

        if (settings.githubPat && settings.gistId) {
            if (hasCoreDataChanged) {
                setSyncStatus(s => s === 'error' ? 'error' : 'syncing');
                if (saveTimeoutRef.current) {
                    clearTimeout(saveTimeoutRef.current);
                }
                saveTimeoutRef.current = setTimeout(async () => {
                    try {
                        const headers = {
                            'Authorization': `token ${settings.githubPat}`,
                            'Accept': 'application/vnd.github.v3+json',
                        };
                        const body = JSON.stringify({
                            files: { [GIST_FILENAME]: { content: JSON.stringify(bullets) } }
                        });
                        const response = await fetch(`${GITHUB_API_URL}/gists/${settings.gistId}`, {
                            method: 'PATCH',
                            headers,
                            body
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.message || `GitHub API error: ${response.statusText}`);
                        }
                        setSyncStatus('synced');
                        prevCoreDataRef.current = currentCoreData;
                    } catch (error) {
                        console.error("Failed to save to Gist:", error);
                        setSyncStatus('error');
                    }
                }, 2000);
            }
        } else {
            setSyncStatus('offline');
        }

    }, [settings, bullets, sidebarWidth, isSidebarCollapsed, getCoreDataString]);
    
    const flatBullets = useMemo(() => {
        const results = [];
        const traverse = (nodes, currentPath) => {
            for (const node of nodes) {
                results.push({
                    id: node.id,
                    text: node.text,
                    path: currentPath,
                });
                if (node.children && node.children.length > 0) {
                    traverse(node.children, [...currentPath, node.text || 'Untitled']);
                }
            }
        };
        traverse(bullets, []);
        return results;
    }, [bullets]);

    const sidebarSearchResults = useMemo(() => {
        if (!sidebarSearchQuery) return [];
        const lowerCaseQuery = sidebarSearchQuery.toLowerCase();
        return flatBullets.filter(b => b.text.toLowerCase().includes(lowerCaseQuery));
    }, [sidebarSearchQuery, flatBullets]);

    const findBulletAndParent = useCallback((
        id,
        nodes,
        parent = null
      ) => {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (node.id === id) {
            return { node, parent, siblings: nodes, index: i };
          }
          const found = findBulletAndParent(id, node.children, node);
          if (found) return found;
        }
        return null;
    }, []);

    // --- Sidebar Data ---
    useEffect(() => {
        const tagsData = new Map();
        const tagRegex = /#(\w+)/g;
        for (const bullet of flatBullets) {
            const matches = bullet.text.match(tagRegex);
            if (matches) {
                for (const match of matches) {
                    const tagName = match.substring(1);
                     if (sidebarTagsSearchQuery && !tagName.toLowerCase().includes(sidebarTagsSearchQuery.toLowerCase())) {
                        continue;
                    }
                    if (!tagsData.has(tagName)) tagsData.set(tagName, []);
                    tagsData.get(tagName).push(bullet);
                }
            }
        }

        const sortedTags = Array.from(tagsData.keys()).sort((a, b) => a.localeCompare(b));
        const tagsBulletChildren = sortedTags.map(tagName => {
            const references = tagsData.get(tagName);
            return {
                id: `tag-#${tagName}`, text: `#${tagName}`,
                children: references.map(ref => ({
                    id: `ref-${ref.id}-${tagName}`, text: ref.text, children: [],
                    isCollapsed: true, isReadOnly: true, originalId: ref.id,
                })),
                isCollapsed: true, isReadOnly: true,
            };
        });

        const tagsBullet = {
            id: 'tags-root', text: TAGS_ROOT_TEXT,
            children: tagsBulletChildren, isCollapsed: true, isReadOnly: true,
        };
        
        const searchBulletChildren = sidebarSearchResults.map(res => ({
            id: `sidebar-res-${res.id}`, text: res.text, children: [], 
            isCollapsed: true, isReadOnly: true, originalId: res.id, path: res.path,
        }));
        
        const searchBullet = {
            id: 'sidebar-search-root', text: SEARCH_ROOT_TEXT,
            children: searchBulletChildren, isCollapsed: !sidebarSearchQuery, isReadOnly: true,
        };

        const currentSearchNode = sidebarTree.find(b => b.id === 'sidebar-search-root');
        if (currentSearchNode) {
            searchBullet.isCollapsed = currentSearchNode.isCollapsed;
        }
        const currentTagsNode = sidebarTree.find(b => b.id === 'tags-root');
        if (currentTagsNode) {
            tagsBullet.isCollapsed = currentTagsNode.isCollapsed;
            tagsBullet.children.forEach(tagChild => {
                const oldTag = currentTagsNode.children.find(t => t.id === tagChild.id);
                if (oldTag) tagChild.isCollapsed = oldTag.isCollapsed;
            });
        }
        
        const newTree = [searchBullet];
        if (tagsBullet.children.length > 0 || sidebarTagsSearchQuery) newTree.push(tagsBullet);
        setSidebarTree(newTree);
    }, [flatBullets, sidebarSearchQuery, sidebarTagsSearchQuery]);

    useEffect(() => {
        const currentId = focusOptions.id;
        const prevId = prevFocusId.current;

        if (prevId && prevId !== currentId) {
            const found = findBulletAndParent(prevId, bullets);
            if (found && !found.node.isReadOnly && found.node.text === '' && found.node.children.length === 0) {
                const newBullets = structuredClone(bullets);
                const foundAgain = findBulletAndParent(prevId, newBullets);
                if (foundAgain) {
                    foundAgain.siblings.splice(foundAgain.index, 1);
                    setBullets(newBullets);
                }
            }
        }

        prevFocusId.current = currentId;
    }, [focusOptions.id, bullets, findBulletAndParent]);


    const breadcrumbs = useMemo(() => {
        if (!zoomedBulletId) return [];
        const path = [];
        const findPath = (nodes, currentPath) => {
            for (const node of nodes) {
                const newPath = [...currentPath, node];
                if (node.id === zoomedBulletId) {
                    path.push(...newPath);
                    return true;
                }
                if (findPath(node.children, newPath)) return true;
            }
            return false;
        };
        findPath(bullets, []);
        return path;
    }, [bullets, zoomedBulletId]);
    
    const handleNavigate = useCallback((bulletId) => {
        const path = [];
        const findPath = (nodes, currentPath) => {
            for (const node of nodes) {
                const newPath = [...currentPath, node];
                if (node.id === bulletId) {
                    path.push(...newPath);
                    return true;
                }
                if (findPath(node.children, newPath)) return true;
            }
            return false;
        };
        findPath(bullets, []);
    
        if (path.length > 0) {
            const parent = path.length > 1 ? path[path.length - 2] : null;
            setZoomedBulletId(parent ? parent.id : null);
            setIsSearchModalOpen(false);
            setTimeout(() => {
                handleFocusChange(bulletId, 'end');
            }, 0);
        }
    }, [bullets, handleFocusChange]);

    const handleZoom = useCallback((id) => {
        const oldZoomedBulletId = zoomedBulletId;
        const isZoomingOut = (id === null && oldZoomedBulletId !== null) || 
                             (id !== null && breadcrumbs.some(b => b.id === id));
        
        if (id === null) { 
            setZoomedBulletId(null);
            if (oldZoomedBulletId) {
                setTimeout(() => handleFocusChange(oldZoomedBulletId), 0);
            } else {
                const getVisibleIds = (nodes) => {
                    let ids = [];
                    for (const node of nodes) {
                        ids.push(node.id);
                        if (!node.isCollapsed && node.children.length > 0) {
                            ids = ids.concat(getVisibleIds(node.children));
                        }
                    }
                    return ids;
                };
                const rootVisibleIds = getVisibleIds(bullets);
                if (rootVisibleIds.length > 0) {
                    handleFocusChange(rootVisibleIds[0]);
                }
            }
            return;
        }
    
        const bulletToZoom = findBulletAndParent(id, bullets)?.node;
    
        if (bulletToZoom && bulletToZoom.children.length === 0 && !bulletToZoom.isReadOnly) {
            const newBullet = createNewBullet();
            const newBullets = structuredClone(bullets);
            const found = findBulletAndParent(id, newBullets);
            if (found) {
                found.node.children.push(newBullet);
                found.node.isCollapsed = false;
                setBullets(newBullets);
                setZoomedBulletId(id);
                setTimeout(() => {
                    handleFocusChange(newBullet.id);
                }, 0);
            } else {
                setZoomedBulletId(id);
            }
        } else if (bulletToZoom) {
            setZoomedBulletId(id);
            if (isZoomingOut && oldZoomedBulletId) {
                setTimeout(() => handleFocusChange(oldZoomedBulletId), 0);
            } else if (bulletToZoom.children.length > 0) {
                 const getVisibleIds = (nodes) => {
                    let ids = [];
                    for (const node of nodes) {
                        ids.push(node.id);
                        if (!node.isCollapsed && node.children.length > 0) {
                            ids = ids.concat(getVisibleIds(node.children));
                        }
                    }
                    return ids;
                };
                const visibleChildrenIds = getVisibleIds(bulletToZoom.children);
                if (visibleChildrenIds.length > 0) {
                    handleFocusChange(visibleChildrenIds[0]);
                }
            }
        }
    }, [zoomedBulletId, bullets, handleFocusChange, breadcrumbs, findBulletAndParent]);

    const displayedBullets = useMemo(() => {
        if (!zoomedBulletId) return bullets;
        const findZoomed = (nodes) => {
            for (const node of nodes) {
                if (node.id === zoomedBulletId) return node;
                const found = findZoomed(node.children);
                if (found) return found;
            }
            return null;
        }
        const zoomedNode = findZoomed(bullets);
        return zoomedNode ? zoomedNode.children : [];
    }, [bullets, zoomedBulletId]);

    const visibleBulletIds = useMemo(() => {
        const getVisibleIds = (nodes) => {
            let ids = [];
            for (const node of nodes) {
                ids.push(node.id);
                if (!node.isCollapsed && node.children.length > 0) {
                    ids = ids.concat(getVisibleIds(node.children));
                }
            }
            return ids;
        };
        return getVisibleIds(displayedBullets);
    }, [displayedBullets]);
    
    useEffect(() => {
        if (!isInitialFocusSet.current && visibleBulletIds.length > 0) {
            handleFocusChange(visibleBulletIds[0], 'end');
            isInitialFocusSet.current = true;
        }
    }, [visibleBulletIds, handleFocusChange]);

    const handleGoToJournal = useCallback(() => {
        const now = new Date();
        const year = now.getFullYear().toString();
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const dayText = `${year}-${month}-${day}`;

        const newBullets = structuredClone(bullets);
        
        let journalNode = newBullets.find((b) => b.text === DAILY_LOG_ROOT_TEXT);
        if (!journalNode) {
            journalNode = createNewBullet(DAILY_LOG_ROOT_TEXT);
            newBullets.unshift(journalNode);
        }

        let yearNode = journalNode.children.find((b) => b.text === year);
        if (!yearNode) {
            yearNode = createNewBullet(year);
            journalNode.children.push(yearNode);
        }

        let monthNode = yearNode.children.find((b) => b.text === month);
        if (!monthNode) {
            monthNode = createNewBullet(month);
            yearNode.children.push(monthNode);
        }
        
        let dayNode = monthNode.children.find((b) => b.text === dayText);
        if (!dayNode) {
            dayNode = createNewBullet(dayText);
            monthNode.children.push(dayNode);
        }
        
        setBullets(newBullets);
        setZoomedBulletId(monthNode.id);
        setTimeout(() => handleFocusChange(dayNode.id), 0);
    }, [bullets, handleFocusChange]);

    const visibleSidebarIds = useMemo(() => {
        const getVisibleIds = (nodes) => {
            let ids = [];
            for (const node of nodes) {
                ids.push(node.id);
                if(node.id === 'sidebar-search-root' && !node.isCollapsed){
                    ids.push('sidebar-search-input');
                }
                if(node.id === 'tags-root' && !node.isCollapsed){
                    ids.push('sidebar-tags-search-input');
                }
                if (!node.isCollapsed && node.children.length > 0) {
                    ids = ids.concat(getVisibleIds(node.children));
                }
            }
            return ids;
        };
        return getVisibleIds(sidebarTree);
    }, [sidebarTree]);

    const mapBullets = (
        nodes,
        callback
    ) => {
        return nodes.map(node => {
            const newNode = callback(node);
            return {
                ...newNode,
                children: mapBullets(newNode.children, callback),
            };
        });
    };
    
    const handleUpdate = useCallback((id, updates) => {
        const found = findBulletAndParent(id, bullets);
        if (found?.node.isReadOnly) return;

        setBullets(prevBullets =>
            mapBullets(prevBullets, bullet =>
                bullet.id === id ? { ...bullet, ...updates } : bullet
            )
        );
    }, [bullets, findBulletAndParent]);
    
    const handleSidebarUpdate = useCallback((id, updates) => {
        if ('isCollapsed' in updates) {
            const mapSidebarTree = (nodes) => {
                return nodes.map(node => {
                    if (node.id === id) {
                        return { ...node, ...updates };
                    }
                    if (node.children) {
                        return { ...node, children: mapSidebarTree(node.children) };
                    }
                    return node;
                });
            };
            setSidebarTree(prev => mapSidebarTree(prev));
        }
    }, []);

    const toggleSidebar = useCallback(() => {
        setIsSidebarCollapsed(prev => {
            const willBeCollapsed = !prev;
            if (willBeCollapsed) {
                setActivePanel('main');
                if (!currentFocusId && visibleBulletIds.length > 0) {
                    handleFocusChange(visibleBulletIds[0]);
                }
            } else {
                setActivePanel('sidebar');
                if (!sidebarFocusId) {
                    handleSidebarUpdate('sidebar-search-root', { isCollapsed: false });
                    setSidebarFocusId('sidebar-search-input');
                }
            }
            return willBeCollapsed;
        });
    }, [visibleBulletIds, currentFocusId, sidebarFocusId, handleFocusChange, handleSidebarUpdate]);

    useEffect(() => {
        const handleGlobalKeyDown = (e) => {
            if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'k') {
                e.preventDefault();
                setIsSearchModalOpen(prev => !prev);
            }
            else if (e.ctrlKey && e.key.toLowerCase() === 'j') {
                e.preventDefault();
                handleGoToJournal();
            }
            else if (e.ctrlKey && e.key === 'ArrowUp') {
                e.preventDefault();
                if (zoomedBulletId) {
                    const parentId = breadcrumbs.length > 1 ? breadcrumbs[breadcrumbs.length - 2].id : null;
                    handleZoom(parentId);
                }
            }
            else if (e.ctrlKey && (e.key === '\\' || e.key === '')) { // `` for some keyboards
                 e.preventDefault();
                 toggleSidebar();
            }
            else if (e.ctrlKey && e.key === "'") {
                e.preventDefault();
                if (activePanel === 'main' && !isSidebarCollapsed) {
                     if (!sidebarFocusId) {
                         handleSidebarUpdate('sidebar-search-root', { isCollapsed: false });
                         setSidebarFocusId('sidebar-search-input');
                     }
                     setActivePanel('sidebar');
                } else {
                    if (!currentFocusId && visibleBulletIds.length > 0) {
                        handleFocusChange(visibleBulletIds[0]);
                    }
                    setActivePanel('main');
                }
            }
            else if ((e.key === 'ArrowDown' || e.key === 'ArrowUp') && !currentFocusId && activePanel === 'main' && visibleBulletIds.length > 0) {
                const target = e.target;
                if(target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
                    e.preventDefault();
                    handleFocusChange(visibleBulletIds[0]);
                }
            }
        };

        window.addEventListener('keydown', handleGlobalKeyDown);
        return () => {
            window.removeEventListener('keydown', handleGlobalKeyDown);
        };
    }, [zoomedBulletId, breadcrumbs, currentFocusId, visibleBulletIds, handleGoToJournal, handleZoom, handleFocusChange, toggleSidebar, isSidebarCollapsed, activePanel, visibleSidebarIds, sidebarFocusId, handleSidebarUpdate]);

    const handleAddSibling = useCallback((id, text = '') => {
        const foundTarget = findBulletAndParent(id, bullets);
        if (foundTarget?.node.isReadOnly) return;

        const newBullet = createNewBullet(text);
        const newBullets = structuredClone(bullets);
        let baseNodes = newBullets;
        if(zoomedBulletId){
            const zoomed = findBulletAndParent(zoomedBulletId, newBullets);
            if(zoomed) baseNodes = zoomed.node.children;
        }
        const found = findBulletAndParent(id, baseNodes);
        if (found) {
            found.siblings.splice(found.index + 1, 0, newBullet);
            setBullets(newBullets);
            handleFocusChange(newBullet.id);
        }
    }, [bullets, zoomedBulletId, handleFocusChange, findBulletAndParent]);

    const handleDelete = useCallback((id) => {
        const foundTarget = findBulletAndParent(id, bullets);
        if (foundTarget?.node.isReadOnly) return;

        const newBullets = structuredClone(bullets);
        const found = findBulletAndParent(id, newBullets);
        if (found) {
            const prevSiblingId = found.index > 0 ? found.siblings[found.index - 1].id : found.parent?.id;
            found.siblings.splice(found.index, 1);
            setBullets(newBullets);
            handleFocusChange(prevSiblingId || null);
        }
    }, [bullets, handleFocusChange, findBulletAndParent]);
    
    const handleIndent = useCallback((id) => {
        const foundTarget = findBulletAndParent(id, bullets);
        if (foundTarget?.node.isReadOnly) return;

        const newBullets = structuredClone(bullets);
        const found = findBulletAndParent(id, newBullets);
        if (found && found.index > 0) {
            const prevSibling = found.siblings[found.index - 1];
             if (prevSibling.isReadOnly) return;
            const [movedNode] = found.siblings.splice(found.index, 1);
            prevSibling.children.push(movedNode);
            prevSibling.isCollapsed = false;
            setBullets(newBullets);
            handleFocusChange(id);
        }
    }, [bullets, handleFocusChange, findBulletAndParent]);
    
    const handleOutdent = useCallback((id) => {
        const foundTarget = findBulletAndParent(id, bullets);
        if (foundTarget?.node.isReadOnly) return;

        const newBullets = structuredClone(bullets);
        const found = findBulletAndParent(id, newBullets);
        if (found && found.parent) {
            const parentInfo = findBulletAndParent(found.parent.id, newBullets);
            if(parentInfo && !parentInfo.node.isReadOnly){
                const [movedNode] = found.siblings.splice(found.index, 1);
                const subsequentSiblings = found.siblings.splice(found.index);
                movedNode.children.push(...subsequentSiblings);

                parentInfo.siblings.splice(parentInfo.index + 1, 0, movedNode);
                setBullets(newBullets);
                handleFocusChange(id);
            }
        }
    }, [bullets, handleFocusChange, findBulletAndParent]);

    const handleFoldAll = useCallback((id, collapse) => {
        const setCollapseRecursively = (nodes) => {
            return nodes.map(node => {
                const newNode = { ...node };
                if (newNode.children.length > 0) {
                    newNode.isCollapsed = collapse;
                    if (!newNode.isReadOnly) {
                        newNode.children = setCollapseRecursively(newNode.children);
                    }
                }
                return newNode;
            });
        };
    
        const findAndFold = (nodes) => {
            return nodes.map(node => {
                if (node.id === id) {
                    const updatedNode = { ...node };
                    if(updatedNode.children.length > 0) {
                        updatedNode.isCollapsed = collapse;
                        updatedNode.children = setCollapseRecursively(updatedNode.children);
                    }
                    return updatedNode;
                }
                if (node.children.length > 0) {
                    return { ...node, children: findAndFold(node.children) };
                }
                return node;
            });
        };
    
        setBullets(prevBullets => findAndFold(prevBullets));
    }, []);

    const handleMoveBullet = useCallback((id, direction) => {
        const foundTarget = findBulletAndParent(id, bullets);
        if (foundTarget?.node.isReadOnly) return;

        const newBullets = structuredClone(bullets);
        const found = findBulletAndParent(id, newBullets);
    
        if (!found) return;
    
        const { siblings, index } = found;
    
        if (direction === 'up') {
            if (index > 0) {
                [siblings[index], siblings[index - 1]] = [siblings[index - 1], siblings[index]];
                setBullets(newBullets);
            }
        } else { // 'down'
            if (index < siblings.length - 1) {
                [siblings[index], siblings[index + 1]] = [siblings[index + 1], siblings[index]];
                setBullets(newBullets);
            }
        }
    }, [bullets, findBulletAndParent]);

    const handleFocusParent = useCallback((id) => {
        const currentTree = zoomedBulletId ? displayedBullets : bullets;
        const findInCurrentView = (
            bulletId,
            nodes,
            parent = null
          ) => {
            for (const node of nodes) {
              if (node.id === bulletId) {
                return { node, parent };
              }
              const found = findInCurrentView(bulletId, node.children, node);
              if (found) return found;
            }
            return null;
        };
        const found = findInCurrentView(id, currentTree);
        if (found?.parent) {
            handleFocusChange(found.parent.id);
        }
    }, [zoomedBulletId, bullets, displayedBullets, handleFocusChange]);

    const handleFocusChild = useCallback((id) => {
        const found = findBulletAndParent(id, bullets);
        if (found?.node && found.node.children.length > 0 && !found.node.isCollapsed) {
            handleFocusChange(found.node.children[0].id, 'start');
        }
    }, [bullets, handleFocusChange, findBulletAndParent]);


    const handleExport = () => {
        const dataStr = JSON.stringify(bullets, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        const exportFileDefaultName = 'workflowy_clone_data.json';
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
    };

    const handleImport = (data) => {
        setBullets(data);
        setZoomedBulletId(null);
        setSearchQuery('');
    };
    
    const handleAddItemToCurrentView = useCallback(() => {
        const newBullet = createNewBullet();
        if (zoomedBulletId) {
            const newBullets = structuredClone(bullets);
            const found = findBulletAndParent(zoomedBulletId, newBullets);
            if (found && !found.node.isReadOnly) {
                found.node.children.push(newBullet);
                found.node.isCollapsed = false;
                setBullets(newBullets);
                handleFocusChange(newBullet.id);
            }
        } else {
            setBullets(prev => [...prev, newBullet]);
            handleFocusChange(newBullet.id);
        }
    }, [bullets, zoomedBulletId, handleFocusChange, findBulletAndParent]);

    const handleFocusMove = useCallback((direction, position = 'end') => {
        if (!currentFocusId) {
            if (visibleBulletIds.length > 0) {
                 handleFocusChange(visibleBulletIds[0], position);
            }
            return;
        }
        const currentIndex = visibleBulletIds.indexOf(currentFocusId);
        if (currentIndex === -1) return;
        let nextIndex;
        if (direction === 'down') {
            nextIndex = currentIndex + 1;
            if (nextIndex < visibleBulletIds.length) {
                handleFocusChange(visibleBulletIds[nextIndex], position);
            }
        } else { // 'up'
            nextIndex = currentIndex - 1;
            if (nextIndex >= 0) {
                handleFocusChange(visibleBulletIds[nextIndex], position);
            }
        }
    }, [currentFocusId, visibleBulletIds, handleFocusChange]);

    // --- Sidebar KeyDown Handler ---
    const handleSidebarKeyDown = useCallback((e) => {
        if (e.target.id === 'sidebar-search-input') {
            if(e.key === 'ArrowDown') {
                e.preventDefault();
                const searchRootIndex = visibleSidebarIds.indexOf('sidebar-search-root');
                if (searchRootIndex !== -1 && visibleSidebarIds.length > searchRootIndex + 2) { // +2 to skip input itself
                    setSidebarFocusId(visibleSidebarIds[searchRootIndex + 2]);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                setSidebarFocusId('sidebar-search-root');
            }
            return;
        };

        if (e.target.id === 'sidebar-tags-search-input') {
            if(e.key === 'ArrowDown') {
                e.preventDefault();
                const tagsRootIndex = visibleSidebarIds.indexOf('tags-root');
                if (tagsRootIndex !== -1 && visibleSidebarIds.length > tagsRootIndex + 2) { 
                    setSidebarFocusId(visibleSidebarIds[tagsRootIndex + 2]);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                setSidebarFocusId('tags-root');
            }
            return;
        }

        const findNode = (id, nodes) => {
            for (const node of nodes) {
                if (node.id === id) return node;
                const found = findNode(id, node.children);
                if (found) return found;
            }
            return null;
        };
        const currentItem = findNode(sidebarFocusId, sidebarTree);

        const moveFocus = (dir) => {
            const currentIndex = visibleSidebarIds.indexOf(sidebarFocusId);
            if (currentIndex === -1) return;
            const nextIndex = dir === 'up' ? currentIndex - 1 : currentIndex + 1;
            if (nextIndex >= 0 && nextIndex < visibleSidebarIds.length) {
                setSidebarFocusId(visibleSidebarIds[nextIndex]);
            }
        };

        let handled = true;
        if (e.ctrlKey) {
            switch (e.key) {
                case 'ArrowDown':
                    if (currentItem && currentItem.originalId) handleNavigate(currentItem.originalId);
                    break;
                case 'ArrowRight':
                    if (currentItem && currentItem.children?.length > 0 && currentItem.isCollapsed) {
                        handleSidebarUpdate(currentItem.id, { isCollapsed: false });
                    }
                    break;
                case 'ArrowLeft':
                     if (currentItem && currentItem.children?.length > 0 && !currentItem.isCollapsed) {
                        handleSidebarUpdate(currentItem.id, { isCollapsed: true });
                    }
                    break;
                default: handled = false;
            }
        } else {
             switch (e.key) {
                case 'ArrowUp': moveFocus('up'); break;
                case 'ArrowDown': moveFocus('down'); break;
                case 'Enter':
                    if (currentItem && currentItem.originalId) handleNavigate(currentItem.originalId);
                    else if (currentItem && (currentItem.children?.length > 0 || currentItem.id === 'sidebar-search-root' || currentItem.id === 'tags-root')) {
                        handleSidebarUpdate(currentItem.id, { isCollapsed: !currentItem.isCollapsed });
                    }
                    break;
                case 'ArrowRight':
                    if (currentItem && (currentItem.children?.length > 0 || currentItem.id === 'sidebar-search-root' || currentItem.id === 'tags-root') && currentItem.isCollapsed) {
                        handleSidebarUpdate(currentItem.id, { isCollapsed: false });
                    }
                    break;
                case 'ArrowLeft':
                    if (currentItem && (currentItem.children?.length > 0 || currentItem.id === 'sidebar-search-root' || currentItem.id === 'tags-root') && !currentItem.isCollapsed) {
                        handleSidebarUpdate(currentItem.id, { isCollapsed: true });
                    }
                    break;
                default: handled = false;
            }
        }
       if (handled) e.preventDefault();
    }, [sidebarFocusId, sidebarTree, visibleSidebarIds, handleNavigate, handleSidebarUpdate]);

    // --- Link Popup Logic ---

    const handleTriggerLinkPopup = useCallback((bulletId, query, inputRef, selectionHandler) => {
        if (!inputRef.current) return;
        const rect = inputRef.current.getBoundingClientRect();
        setLinkSelectionHandler({ handler: selectionHandler });

        const POPUP_MAX_WIDTH_PX = 768; // Corresponds to Tailwind's max-w-2xl
        const VIEWPORT_PADDING_PX = 16;
        
        let left = rect.left + window.scrollX;
        
        if (left + POPUP_MAX_WIDTH_PX > window.innerWidth - VIEWPORT_PADDING_PX) {
            left = window.innerWidth - POPUP_MAX_WIDTH_PX - VIEWPORT_PADDING_PX;
        }

        left = Math.max(VIEWPORT_PADDING_PX, left);

        const suggestions = !query 
            ? flatBullets.slice(0, 50) 
            : flatBullets.map(bullet => {
                const lowerText = bullet.text.toLowerCase();
                const lowerQuery = query.toLowerCase();
                let score = 0;
                if (lowerText.startsWith(lowerQuery)) {
                    score = 2;
                } else if (lowerText.includes(lowerQuery)) {
                    score = 1;
                }
                return { ...bullet, score };
            })
            .filter(bullet => bullet.score > 0 && bullet.id !== bulletId) 
            .sort((a, b) => b.score - a.score);

        setLinkPopupState({
            isOpen: true,
            targetId: bulletId,
            query: query,
            position: { top: rect.bottom + window.scrollY, left: left },
            suggestions: suggestions.slice(0, 100), 
            selectedIndex: 0,
        });

    }, [flatBullets]);

    const handleCloseLinkPopup = useCallback(() => {
        setLinkPopupState(prev => {
            if (prev.isOpen) {
                return { ...prev, isOpen: false };
            }
            return prev;
        });
        setLinkSelectionHandler({ handler: null });
    }, []);

    const handleLinkNavigate = useCallback((direction) => {
        if (!linkPopupState.isOpen) return;
        setLinkPopupState(prev => {
            const { suggestions, selectedIndex } = prev;
            let nextIndex = selectedIndex;
            if (direction === 'down') {
                nextIndex = (selectedIndex + 1) % suggestions.length;
            } else {
                nextIndex = (selectedIndex - 1 + suggestions.length) % suggestions.length;
            }
            return { ...prev, selectedIndex: nextIndex };
        });
    }, [linkPopupState.isOpen]);
    
    const handleLinkSelect = useCallback((callback) => {
        if (!linkPopupState.isOpen || linkPopupState.suggestions.length === 0) return;
        const selectedBullet = linkPopupState.suggestions[linkPopupState.selectedIndex];
        callback(selectedBullet);
    }, [linkPopupState]);

    const handleLinkClick = useCallback((linkText) => {
        let targetBullet = null;
        const find = (nodes) => {
            for (const node of nodes) {
                if (node.text === linkText) {
                    targetBullet = node;
                    return true;
                }
                if (find(node.children)) return true;
            }
            return false;
        };
        find(bullets);
    
        if (targetBullet) {
            const path = [];
            const findPath = (nodes, currentPath) => {
                for (const node of nodes) {
                    const newPath = [...currentPath, node];
                    if (node.id === targetBullet.id) {
                        path.push(...newPath);
                        return true;
                    }
                    if (findPath(node.children, newPath)) return true;
                }
                return false;
            };
            findPath(bullets, []);
            
            const parent = path.length > 1 ? path[path.length - 2] : null;
            setZoomedBulletId(parent ? parent.id : null);
            setTimeout(() => handleFocusChange(targetBullet.id, 'end'), 0);
        } else {
            console.warn(`Link target not found: "${linkText}"`);
        }
    }, [bullets, handleFocusChange]);

    // --- Sidebar Resize Logic ---
    const handleResizeMouseDown = (e) => {
        e.preventDefault();
        setIsResizing(true);
    };

    const handleResizeMouseMove = useCallback((e) => {
        if (isResizing) {
            const newWidth = window.innerWidth - e.clientX;
            const MIN_WIDTH = 200;
            const MAX_WIDTH = 500;
            setSidebarWidth(Math.max(MIN_WIDTH, Math.min(newWidth, MAX_WIDTH)));
        }
    }, [isResizing]);

    const handleResizeMouseUp = useCallback(() => {
        setIsResizing(false);
    }, []);

    useEffect(() => {
        window.addEventListener('mousemove', handleResizeMouseMove);
        window.addEventListener('mouseup', handleResizeMouseUp);
        return () => {
            window.removeEventListener('mousemove', handleResizeMouseMove);
            window.removeEventListener('mouseup', handleResizeMouseUp);
        };
    }, [handleResizeMouseMove, handleResizeMouseUp]);


    return (
        <div className="h-screen w-screen flex flex-col">
            <Toolbar
                onImport={handleImport}
                onExport={handleExport}
                breadcrumbs={breadcrumbs}
                onBreadcrumbClick={handleZoom}
                fileName={settings.fileName}
                onOpenSettings={() => setIsSettingsModalOpen(true)}
                syncStatus={syncStatus}
                onGoToToday={handleGoToJournal}
                theme={theme}
                onThemeToggle={handleThemeToggle}
                onToggleSidebar={toggleSidebar}
                isSidebarCollapsed={isSidebarCollapsed}
            />
            <div className="flex flex-grow overflow-hidden">
                <main className={`flex-grow overflow-y-auto p-4 md:px-8 lg:px-16 xl:px-32 outline-none ${activePanel === 'main' ? 'focus-outline' : ''}`}>
                    {displayedBullets.length > 0 ? displayedBullets.map(bullet => (
                        <div key={bullet.id}>
                            <BulletItem
                                bullet={bullet}
                                level={0}
                                onUpdate={handleUpdate}
                                onAddSibling={handleAddSibling}
                                onDelete={handleDelete}
                                onIndent={handleIndent}
                                onOutdent={handleOutdent}
                                onFocusChange={handleFocusChange}
                                onZoom={handleZoom}
                                onFocusMove={handleFocusMove}
                                onFocusParent={handleFocusParent}
                                onFocusChild={handleFocusChild}
                                onFoldAll={handleFoldAll}
                                onMoveBullet={handleMoveBullet}
                                currentFocusId={currentFocusId}
                                focusPosition={focusPosition}
                                searchQuery={searchQuery}
                                onLinkClick={handleLinkClick}
                                onTriggerLinkPopup={handleTriggerLinkPopup}
                                onCloseLinkPopup={handleCloseLinkPopup}
                                onLinkNavigate={handleLinkNavigate}
                                onLinkSelect={handleLinkSelect}
                                isLinkPopupOpen={linkPopupState.isOpen}
                                linkPopupTargetId={linkPopupState.targetId}
                                isJournalRoot={bullet.text === DAILY_LOG_ROOT_TEXT && zoomedBulletId === null}
                                isTagsRoot={false}
                                onNavigateTo={handleNavigate}
                                activePanel={activePanel}
                            />
                        </div>
                    )) : (
                        <div className="flex justify-center items-center h-full text-gray-400 dark:text-gray-500">
                            <button onClick={handleAddItemToCurrentView} className="border border-dashed border-gray-300 dark:border-gray-600 px-4 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition-colors">
                               {zoomedBulletId ? 'Add an item here' : 'Start with a new item'}
                            </button>
                        </div>
                    )}
                     {linkPopupState.isOpen && (
                        <LinkPopup
                            suggestions={linkPopupState.suggestions}
                            selectedIndex={linkPopupState.selectedIndex}
                            onSelect={(bullet) => {
                                if (linkSelectionHandler.handler) {
                                    linkSelectionHandler.handler(bullet);
                                }
                            }}
                            position={linkPopupState.position}
                            containerRef={linkPopupRef}
                        />
                    )}
                </main>
                {!isSidebarCollapsed && (
                    <Resizer onMouseDown={handleResizeMouseDown} />
                )}
                {!isSidebarCollapsed && (
                    <div style={{ width: `${sidebarWidth}px` }} className="flex-shrink-0 h-full">
                         <Sidebar
                            sidebarTree={sidebarTree}
                            onSidebarUpdate={handleSidebarUpdate}
                            onNavigateTo={handleNavigate}
                            sidebarFocusId={sidebarFocusId}
                            activePanel={activePanel}
                            sidebarSearchQuery={sidebarSearchQuery}
                            onSearchQueryChange={setSidebarSearchQuery}
                            sidebarTagsSearchQuery={sidebarTagsSearchQuery}
                            onTagsSearchQueryChange={setSidebarTagsSearchQuery}
                            onSidebarKeyDown={handleSidebarKeyDown}
                            onSidebarFocus={handleSidebarFocus}
                        />
                    </div>
                )}
            </div>
             <SearchModal
                isOpen={isSearchModalOpen}
                onClose={() => setIsSearchModalOpen(false)}
                bullets={flatBullets}
                onNavigate={handleNavigate}
            />
            <SettingsModal 
                isOpen={isSettingsModalOpen}
                onClose={() => setIsSettingsModalOpen(false)}
                onSave={setSettings}
                currentSettings={settings}
            />
        </div>
    );
};


const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
    <App />
);
    </script>
  </body>
</html>