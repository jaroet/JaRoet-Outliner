


<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/png" href="./jr_favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JaRoet Outliner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
      }
    </script>
    <style>
      :root {
        --main-color: #60a5fa;
        --font-family: sans-serif;
        --font-size: 16px;
      }
      body {
        font-family: var(--font-family);
        font-size: var(--font-size);
        overflow: hidden; /* Prevent body scroll when resizing */
        line-height: 1.5;
      }

      /* Ensure form elements inherit font settings from body */
      input, textarea, button, select {
        font-family: inherit;
        font-size: inherit;
      }

      /* Simple scrollbar styling for a more modern look */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      /* Light theme */
      ::-webkit-scrollbar-track {
        background: #f1f5f9; /* cool-gray-100 */
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1; /* cool-gray-300 */
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #94a3b8; /* cool-gray-400 */
      }
      /* Dark theme */
      .dark ::-webkit-scrollbar-track {
        background: #1e293b; /* slate-800 */
      }
      .dark ::-webkit-scrollbar-thumb {
        background: #475569; /* slate-600 */
      }
      .dark ::-webkit-scrollbar-thumb:hover {
        background: #64748b; /* slate-500 */
      }
      .focus-outline {
        outline: 2px solid var(--main-color);
        outline-offset: -1px;
        border-radius: 4px;
      }
      .selected-item-bg {
        /* Mix with 20% black to darken the main color, ensuring good contrast with white text */
        background-color: color-mix(in srgb, var(--main-color) 80%, black);
      }
      .tag-span {
        background-color: color-mix(in srgb, var(--main-color) 20%, transparent);
        color: color-mix(in srgb, var(--main-color) 70%, black);
        border-radius: 0.375rem; /* rounded-md */
        padding: 0.125rem 0.25rem; /* py-0.5 px-1 */
        margin: 0 0.0625rem; /* mx-px */
        font-size: 0.875rem; /* text-sm */
      }

      .dark .tag-span {
        color: var(--main-color);
      }

      @keyframes fadeInUp {
          from {
              opacity: 0;
              transform: translate3d(0, 100%, 0);
          }
          to {
              opacity: 1;
              transform: translate3d(0, 0, 0);
          }
      }

      .animate-fade-in-up {
          animation: fadeInUp 0.3s ease-out;
      }
    </style>
    <!-- Add Babel for in-browser JSX/TS transformation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Add Dexie.js for IndexedDB -->
    <script src="https://unpkg.com/dexie@4.0.7/dist/dexie.js"></script>
    <!-- Configure Babel -->
    <script>
      Babel.config({
        presets: [
          ["env", { "modules": false }],
          "react",
          "typescript"
        ]
      });
    </script>
    <script type="importmap">
    {
      "imports": {
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react/": "https://aistudiocdn.com/react@^19.2.0/",
        "react-dom": "https://aistudiocdn.com/react-dom@^19.2.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
        "react-dom/client": "https://aistudiocdn.com/react-dom@^19.2.0/client"
      }
    }
    </script>
</head>
  <body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 antialiased transition-colors duration-200">
    <div id="root"></div>
    
    <script>
      // Polyfill for crypto.randomUUID if not available
      if (!crypto.randomUUID) {
        crypto.randomUUID = () => {
          if (crypto.getRandomValues) {
             return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
               (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
             );
          } else {
             return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
             });
          }
        };
      }
    </script>

    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
      import { createRoot } from 'react-dom/client';

      // ==========================================
      // 1. TYPES & INTERFACES
      // ==========================================
      
      export interface Bullet {
        id: string;
        text: string;
        children: Bullet[];
        isCollapsed: boolean;
        isReadOnly?: boolean;
        isFavorite?: boolean;
        originalId?: string;
        createdAt?: number;
        updatedAt?: number;
      }

      export interface FlatBullet {
        id: string;
        text: string;
        path: string[];
        createdAt?: number;
        updatedAt?: number;
      }

      export interface Settings {
        mainColor: string;
        fileName: string;
        fontFamily: string;
        fontSize: number;
      }

      export type CoreBullet = {
        id: string;
        text: string;
        children: CoreBullet[];
        isFavorite?: boolean;
        originalId?: string;
        createdAt?: number;
        updatedAt?: number;
      };

      // ==========================================
      // 2. ICONS
      // ==========================================

      const ChevronRightIcon = ({ className = 'w-4 h-4' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m8.25 4.5 7.5 7.5-7.5 7.5" />
        </svg>
      );

      const ChevronDownIcon = ({ className = 'w-4 h-4' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" />
        </svg>
      );

      const CircleIcon = ({ className = 'w-2 h-2', color = 'var(--main-color)' }) => (
        <svg viewBox="0 0 100 100" className={className}>
          <circle cx="50" cy="50" r="50" fill={color} />
        </svg>
      );

      const SearchIcon = ({ className = 'w-5 h-5' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
          <path strokeLinecap="round" strokeLinejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
        </svg>
      );

      const UploadIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" />
          </svg>
      );

      const DownloadIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" />
          </svg>
      );

      const HomeIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}>
            <path d="M11.47 3.84a.75.75 0 011.06 0l8.69 8.69a.75.75 0 101.06-1.06l-8.689-8.69a2.25 2.25 0 00-3.182 0l-8.69 8.69a.75.75 0 001.061 1.06l8.69-8.69z" />
            <path d="M12 5.432L4.432 13v6.75a2.25 2.25 0 002.25 2.25h10.636a2.25 2.25 0 002.25-2.25v-6.75L12 5.432z" />
          </svg>
      );

      const AppointmentIcon = ({ className = 'w-4 h-4' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M6.75 3v2.25M17.25 3v2.25M3 18.75V7.5a2.25 2.25 0 0 1 2.25-2.25h13.5A2.25 2.25 0 0 1 21 7.5v11.25m-18 0A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75m-18 0h18" />
          </svg>
      );

      const SettingsIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.242 1.41l-1.028.937c-.28.254-.434.62-.434.995s.154.74.434.995l1.028.937a1.125 1.125 0 01-.242 1.41l1.296-2.247a1.125 1.125 0 011.37.49l1.217.456c-.355-.133-.75-.072-1.075.124a6.57 6.57 0 01-.22.127c-.331.183-.581.495-.645.87l-.213 1.281c-.09.543-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.313-.686-.645-.87a6.52 6.52 0 01-.22-.127c-.324-.196-.72-.257-1.075-.124l-1.217.456a1.125 1.125 0 01-1.37-.49l-1.296-2.247a1.125 1.125 0 01.242-1.41l1.028-.937c.28-.254.434.62.434.995s-.154-.74-.434-.995l-1.028-.937a1.125 1.125 0 01-.242-1.41l1.296-2.247a1.125 1.125 0 011.37.49l1.217.456c.355.133.75.072 1.075-.124.073-.044.146-.087.22-.127.332-.183.582-.495.645-.87l.213-1.281z" />
              <path strokeLinecap="round" strokeLinejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
      );

      const SunIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 3v2.25m6.364.386-1.591 1.591M21 12h-2.25m-.386 6.364-1.591-1.591M12 18.75V21m-4.95-4.223-1.591 1.591M5.25 12H3m4.223-4.95-1.591-1.591M12 6a6 6 0 1 0 0 12 6 6 0 0 0 0-12Z" />
          </svg>
      );

      const MoonIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M21.752 15.002A9.72 9.72 0 0 1 18 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 0 0 3 11.25c0 5.385 4.365 9.75 9.75 9.75 2.806 0 5.347-1.257 7.141-3.248a9.753 9.753 0 0 1 1.861-3.75Z" />
          </svg>
      );

      const TrashIcon = ({ className = 'w-5 h-5' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" />
          </svg>
      );

      const SidebarIcon = ({ className = 'w-5 h-5' }) => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
            <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
        </svg>
      );

      const ClockIcon = ({ className = 'w-4 h-4' }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth="1.5" stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
          </svg>
      );

      const StarIcon = ({ className = 'w-5 h-5', filled = false }) => (
          <svg xmlns="http://www.w3.org/2000/svg" fill={filled ? "currentColor" : "none"} viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className={className}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M11.48 3.499a.562.562 0 0 1 1.04 0l2.125 5.111a.563.563 0 0 0 .475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 0 0-.182.557l1.285 5.385a.562.562 0 0 1-.84.61l-4.725-2.885a.562.562 0 0 0-.586 0L6.982 20.54a.562.562 0 0 1-.84-.61l1.285-5.386a.562.562 0 0 0-.182-.557l-4.204-3.602a.562.562 0 0 1 .321-.988l5.518-.442a.563.563 0 0 0 .475-.345L11.48 3.5Z" />
          </svg>
      );

      // ==========================================
      // 3. TOAST COMPONENT
      // ==========================================

      const useToast = () => {
          const [toasts, setToasts] = useState([]);

          const addToast = useCallback((message, type = 'info') => {
              const id = crypto.randomUUID();
              setToasts(prev => [...prev, { id, message, type }]);
              setTimeout(() => {
                  setToasts(prev => prev.filter(t => t.id !== id));
              }, 3000);
          }, []);

          const removeToast = useCallback((id) => {
              setToasts(prev => prev.filter(t => t.id !== id));
          }, []);

          return { toasts, addToast, removeToast };
      };

      const ToastContainer = ({ toasts, removeToast }) => {
          return (
              <div className="fixed bottom-10 left-1/2 transform -translate-x-1/2 flex flex-col gap-2 z-50 pointer-events-none">
                  {toasts.map(toast => (
                      <div
                          key={toast.id}
                          className={`px-4 py-2 rounded-md shadow-lg text-white text-sm font-medium transition-all duration-300 animate-fade-in-up pointer-events-auto ${
                              toast.type === 'success' ? 'bg-green-600' : 
                              toast.type === 'error' ? 'bg-red-600' : 
                              'bg-gray-800 dark:bg-gray-600'
                          }`}
                          onClick={() => removeToast(toast.id)}
                      >
                          {toast.message}
                      </div>
                  ))}
              </div>
          );
      };

      // ==========================================
      // 4. HELPER COMPONENTS
      // ==========================================

      const navigateSuggestions = (prevState, direction) => {
          const { suggestions, selectedIndex } = prevState; 
          const count = suggestions.length; 
          if (count === 0) return selectedIndex;
          if (direction === 'down') {
              return (selectedIndex + 1) % count;
          } else { 
              return (selectedIndex - 1 + count) % count;
          }
      };

      const LinkPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
        const selectedItemRef = useRef(null);
        
        useEffect(() => {
          if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        if (suggestions.length === 0) return null;

        return (
          <div
            className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-full max-w-2xl"
            style={{ top: position.top, left: position.left }}
          >
            <ul ref={containerRef}>
              {suggestions.map((bullet, index) => (
                <li key={bullet.id} ref={index === selectedIndex ? selectedItemRef : null}>
                  <button
                    onClick={() => onSelect(bullet)}
                    className={`w-full text-left px-3 py-2 text-sm ${
                      index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                    }`}
                     title={bullet.text}
                  >
                    <span className="truncate block">{bullet.text || <em>Untitled</em>}</span>
                    {bullet.path.length > 0 && (
                        <span className={`text-xs truncate block ${
                          index === selectedIndex ? 'text-white/80' : 'text-gray-400 dark:text-gray-500'
                        }`}>{bullet.path.join(' / ')}</span>
                    )}
                  </button>
                </li>
              ))}
            </ul>
          </div>
        );
      };

      const TagPopup = ({ suggestions, selectedIndex, onSelect, position, containerRef }) => {
        const selectedItemRef = useRef(null);
        
        useEffect(() => {
          if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
          }
        }, [selectedIndex]);

        if (suggestions.length === 0) {
          return null;
        }

        return (
          <div
            className="absolute z-20 bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto w-auto min-w-[150px]"
            style={{ top: position.top, left: position.left }}
          >
            <ul ref={containerRef}>
              {suggestions.map((tag, index) => (
                <li key={tag} ref={index === selectedIndex ? selectedItemRef : null}>
                  <button
                    onClick={() => onSelect(tag)}
                    className={`w-full text-left px-3 py-2 text-sm ${
                      index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'
                    }`}
                     title={tag}
                  >
                    <span className="truncate block">{tag}</span>
                  </button>
                </li>
              ))}
            </ul>
          </div>
        );
      };

      const ImportSelectionModal = ({ isOpen, onClose, onConfirm, bullets }) => {
          const [searchQuery, setSearchQuery] = useState('');
          const [selectedId, setSelectedId] = useState(null);
          const searchInputRef = useRef(null);

          useEffect(() => {
              if (isOpen) {
                  setSearchQuery('');
                  setSelectedId(null); 
                  setTimeout(() => {
                      searchInputRef.current?.focus();
                  }, 50);
              }
          }, [isOpen]);

          const flatBullets = useMemo(() => {
              if (!isOpen) return [];
              const results = [];
              const traverse = (nodes, currentPath) => {
                  for (const node of nodes) {
                      results.push({
                          id: node.id,
                          text: node.text,
                          path: currentPath,
                          createdAt: node.createdAt,
                          updatedAt: node.updatedAt,
                      });
                      if (node.children && node.children.length > 0) {
                          traverse(node.children, [...currentPath, node.text || 'Untitled']);
                      }
                  }
              };
              traverse(bullets, []);
              return results;
          }, [bullets, isOpen]);

          const filteredBullets = useMemo(() => {
              if (!searchQuery.trim()) return [];
              const lowerQuery = searchQuery.toLowerCase();
              return flatBullets.filter(b => b.text.toLowerCase().includes(lowerQuery)).slice(0, 50);
          }, [flatBullets, searchQuery]);

          if (!isOpen) return null;

          return (
              <div 
                  className="fixed inset-0 bg-black/60 z-40 flex justify-center items-center"
                  onClick={onClose}
              >
                  <div 
                      className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md overflow-hidden flex flex-col max-h-[80vh]"
                      onClick={e => e.stopPropagation()}
                  >
                      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
                          <h2 className="text-lg font-semibold text-gray-800 dark:text-gray-200">Import Content</h2>
                          <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                              Where do you want to place the imported items?
                          </p>
                      </div>

                      <div className="p-4 overflow-y-auto flex-grow">
                          <div 
                              onClick={() => setSelectedId(null)}
                              className={`p-3 rounded-md cursor-pointer border transition-colors flex items-center gap-3 mb-4 ${
                                  selectedId === null 
                                      ? 'bg-[var(--main-color)]/10 border-[var(--main-color)]' 
                                      : 'border-gray-200 dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-700'
                              }`}
                          >
                              <div className={`w-4 h-4 rounded-full border flex items-center justify-center ${
                                  selectedId === null 
                                      ? 'border-[var(--main-color)]' 
                                      : 'border-gray-400'
                              }`}>
                                  {selectedId === null && <div className="w-2 h-2 rounded-full bg-[var(--main-color)]" />}
                              </div>
                              <div>
                                  <span className="block font-medium text-gray-800 dark:text-gray-200">Root (Top Level)</span>
                                  <span className="text-xs text-gray-500 dark:text-gray-400">Add as new items at the bottom of your outline</span>
                              </div>
                          </div>

                          <div className="relative">
                              <div className="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Or select a specific item:</div>
                              <input
                                  ref={searchInputRef}
                                  type="text"
                                  placeholder="Search for an item..."
                                  value={searchQuery}
                                  onChange={(e) => setSearchQuery(e.target.value)}
                                  className="w-full bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)] mb-2"
                              />
                              
                              <div className="max-h-40 overflow-y-auto border border-gray-200 dark:border-gray-700 rounded-md">
                                  {filteredBullets.length > 0 ? (
                                      <ul>
                                          {filteredBullets.map(bullet => (
                                              <li 
                                                  key={bullet.id}
                                                  onClick={() => setSelectedId(bullet.id)}
                                                  className={`px-3 py-2 cursor-pointer flex items-center gap-2 text-sm ${
                                                      selectedId === bullet.id 
                                                          ? 'selected-item-bg text-white' 
                                                          : 'hover:bg-gray-100 dark:hover:bg-gray-700 text-gray-800 dark:text-gray-200'
                                                  }`}
                                              >
                                                  <CircleIcon className="w-1.5 h-1.5 flex-shrink-0" />
                                                  <span className="truncate">{bullet.text || <em>Untitled</em>}</span>
                                              </li>
                                          ))}
                                      </ul>
                                  ) : (
                                      <div className="p-2 text-center text-xs text-gray-500 dark:text-gray-400">
                                          {searchQuery ? 'No items found' : 'Type to search...'}
                                      </div>
                                  )}
                              </div>
                          </div>
                          
                          {selectedId && (
                              <div className="mt-4 p-2 bg-blue-50 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300 text-sm rounded border border-blue-100 dark:border-blue-800">
                                  Items will be added as children of the selected item.
                              </div>
                          )}
                      </div>

                      <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex justify-end gap-2">
                          <button 
                              onClick={onClose}
                              className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white"
                          >
                              Cancel
                          </button>
                          <button 
                              onClick={onConfirm} // Fixed usage to match internal component prop
                              className="px-4 py-2 rounded-md bg-[var(--main-color)] text-white hover:opacity-90"
                          >
                              Import
                          </button>
                      </div>
                  </div>
              </div>
          );
      };

      // ==========================================
      // 5. MAIN COMPONENTS
      // ==========================================

      const LeftSidebar = React.memo(({ isOpen, recents, favorites, onNavigate }) => {
          const [width, setWidth] = useState(256);
          const [isRecentsCollapsed, setIsRecentsCollapsed] = useState(false);
          const [isFavoritesCollapsed, setIsFavoritesCollapsed] = useState(false);
          const [isResizing, setIsResizing] = useState(false);

          const startResizing = useCallback((mouseDownEvent) => {
              mouseDownEvent.preventDefault();
              setIsResizing(true);
              const startX = mouseDownEvent.clientX;
              const startWidth = width;

              const doDrag = (mouseMoveEvent) => {
                  const newWidth = startWidth + (mouseMoveEvent.clientX - startX);
                  if (newWidth > 150 && newWidth < 600) {
                      setWidth(newWidth);
                  }
              };

              const stopDrag = () => {
                  setIsResizing(false);
                  document.removeEventListener('mousemove', doDrag);
                  document.removeEventListener('mouseup', stopDrag);
              };

              document.addEventListener('mousemove', doDrag);
              document.addEventListener('mouseup', stopDrag);
          }, [width]);

          if (!isOpen) return null;

          return (
              <div 
                  className="flex-shrink-0 border-r border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900/50 flex flex-col h-full relative group/sidebar text-[var(--main-color)]"
                  style={{ width: `${width}px` }}
              >
                  {/* Resizer Handle */}
                  <div 
                      className={`absolute right-[-2px] top-0 bottom-0 w-1 cursor-col-resize z-10 hover:bg-blue-400/50 transition-colors ${isResizing ? 'bg-blue-400/50' : ''}`}
                      onMouseDown={startResizing}
                  />

                  <div className="flex flex-col h-full overflow-y-auto overflow-x-hidden">
                      {/* Favorites Section */}
                      <div>
                          <div 
                              className="p-3 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800/50 select-none"
                              onClick={() => setIsFavoritesCollapsed(!isFavoritesCollapsed)}
                          >
                              <div className="flex items-center gap-2">
                                  <StarIcon className="w-4 h-4" />
                                  <span className="font-bold">Favorites</span>
                              </div>
                              <button className="opacity-70">
                                  {isFavoritesCollapsed ? <ChevronRightIcon className="w-4 h-4" /> : <ChevronDownIcon className="w-4 h-4" />}
                              </button>
                          </div>

                          {!isFavoritesCollapsed && (
                              <div className="p-2">
                                  {favorites.length === 0 ? (
                                      <div className="text-xs opacity-80 text-center my-2 italic">
                                          No favorites yet
                                      </div>
                                  ) : (
                                      <ul className="space-y-0">
                                          {favorites.map(item => (
                                              <li key={item.id}>
                                                  <button
                                                      onClick={() => onNavigate(item.id)}
                                                      className="w-full text-left px-3 py-1 rounded-md hover:bg-gray-200 dark:hover:bg-gray-800 transition-colors group"
                                                  >
                                                      <div className="truncate">
                                                          {item.text || <em className="opacity-60">Untitled</em>}
                                                      </div>
                                                  </button>
                                              </li>
                                          ))}
                                      </ul>
                                  )}
                              </div>
                          )}
                      </div>

                      {/* Recents Section */}
                      <div className="border-t border-gray-200 dark:border-gray-700">
                          <div 
                              className="p-3 border-b border-gray-200 dark:border-gray-700 flex items-center justify-between cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-800/50 select-none"
                              onClick={() => setIsRecentsCollapsed(!isRecentsCollapsed)}
                          >
                              <div className="flex items-center gap-2">
                                  <ClockIcon className="w-4 h-4" />
                                  <span className="font-bold">Recents</span>
                              </div>
                              <button className="opacity-70">
                                  {isRecentsCollapsed ? <ChevronRightIcon className="w-4 h-4" /> : <ChevronDownIcon className="w-4 h-4" />}
                              </button>
                          </div>

                          {!isRecentsCollapsed && (
                              <div className="p-2">
                                  {recents.length === 0 ? (
                                      <div className="text-xs opacity-80 text-center my-2 italic">
                                          No recent changes
                                      </div>
                                  ) : (
                                      <ul className="space-y-0">
                                          {recents.map(item => (
                                              <li key={item.id}>
                                                  <button
                                                      onClick={() => onNavigate(item.id)}
                                                      className="w-full text-left px-3 py-1 rounded-md hover:bg-gray-200 dark:hover:bg-gray-800 transition-colors group"
                                                  >
                                                      <div className="truncate">
                                                          {item.text || <em className="opacity-60">Untitled</em>}
                                                      </div>
                                                  </button>
                                              </li>
                                          ))}
                                      </ul>
                                  )}
                              </div>
                          )}
                      </div>
                  </div>
              </div>
          );
      });

      // (See BulletItem.tsx, Toolbar.tsx, etc. for other components - assumed to be part of the full build)
      // For brevity in this update, we are focusing on the updated LeftSidebar logic.
      // But we must provide the App component to update the version number.

      // We need to redefine Toolbar, BulletItem, SearchModal, SettingsModal, etc if we want the full single file to work
      // effectively in a real scenario, but for the XML output we assume standard merging unless explicit full file is requested.
      // Since the prompt asks for "index.html" update, and the file is large, I will provide the FULL content with the
      // necessary components included, assuming I have access to them (which I do from the prompt).
      
      // Let's reimplement the other components quickly inside the single file structure to ensure it works.
      
      const Toolbar = React.memo(({
        onImport,
        onExport,
        breadcrumbs,
        onBreadcrumbClick,
        fileName,
        onOpenSettings,
        onGoToToday,
        theme,
        onThemeToggle,
        onOpenSearch,
        isSidebarOpen,
        onToggleSidebar,
        isFavorite,
        onToggleFavorite,
        canFavorite,
      }) => {
        const fileInputRef = useRef(null);

        const handleImportClick = () => {
          fileInputRef.current?.click();
        };

        const handleFileChange = (event) => {
          const file = event.target.files?.[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const content = e.target?.result;
                const data = JSON.parse(content);
                if (Array.isArray(data) && data.every(item => 'id' in item && 'text' in item)) {
                  onImport(data);
                } else {
                  alert('Invalid JSON file format.');
                }
              } catch (error) {
                alert('Error parsing JSON file.');
                console.error(error);
              }
            };
            reader.readAsText(file);
          }
          if(event.target) event.target.value = '';
        };

        return (
          <div className="flex-shrink-0 sticky top-0 z-20 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm p-2 flex items-center gap-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
              <button 
                  onClick={onToggleSidebar} 
                  className={`p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${isSidebarOpen ? 'bg-gray-100 dark:bg-gray-700' : ''}`}
                  title={isSidebarOpen ? "Hide Sidebar" : "Show Sidebar"}
              >
                  <SidebarIcon />
              </button>

              <div className="flex-grow flex items-center gap-2 overflow-hidden">
                  <button onClick={() => onBreadcrumbClick(null)} className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <HomeIcon />
                  </button>
                  {breadcrumbs.map((crumb, index) => (
                      <React.Fragment key={crumb.id}>
                      <span className="text-gray-400 dark:text-gray-500">/</span>
                      <button
                          onClick={() => onBreadcrumbClick(crumb.id)}
                          className="px-2 py-1 text-sm text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors truncate"
                          title={crumb.text}
                      >
                          {crumb.text || <em>Untitled</em>}
                      </button>
                      </React.Fragment>
                  ))}
              </div>

            <div className="flex items-center gap-2">
               <button onClick={onOpenSearch} title="Quick Find (Ctrl+Shift+K)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                  <SearchIcon />
              </button>
              <button onClick={onGoToToday} title="Go to Today's Log (Ctrl+J)" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                  <AppointmentIcon className="w-5 h-5" />
              </button>
              <button 
                  onClick={onToggleFavorite} 
                  title={isFavorite ? "Remove from Favorites" : "Add to Favorites"}
                  className={`p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors ${!canFavorite ? 'opacity-50 cursor-not-allowed' : ''}`}
                  disabled={!canFavorite}
              >
                  <StarIcon filled={isFavorite} />
              </button>

              <div className="flex items-center gap-1">
                  <input
                      type="file"
                      ref={fileInputRef}
                      className="hidden"
                      accept=".json"
                      onChange={handleFileChange}
                  />
                  <button onClick={handleImportClick} title="Import from JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <UploadIcon />
                  </button>
                  <button onClick={onExport} title="Export to JSON" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <DownloadIcon />
                  </button>
                  <button onClick={onThemeToggle} title="Toggle Theme" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      {theme === 'dark' ? <SunIcon /> : <MoonIcon />}
                  </button>
                  <button onClick={onOpenSettings} title="Settings" className="p-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors">
                      <SettingsIcon />
                  </button>
              </div>
            </div>
          </div>
        );
      });

      // Helper for rich text
      const renderLinksAndTags = (text) => {
           const parts = text.split(/(\[\[.*?\]\]|#\w+)/g);
           return parts.map((part, i) => {
              if (part.startsWith('[[') && part.endsWith(']]')) {
                   return <span key={i} className="text-[var(--main-color)] opacity-80 cursor-pointer hover:underline">{part}</span>;
              }
              if (part.startsWith('#')) {
                   return <span key={i} className="text-[var(--main-color)] opacity-80 cursor-pointer hover:underline">{part}</span>;
              }
              const lines = part.split('\n');
              return lines.map((line, j) => (
                  <React.Fragment key={`${i}-${j}`}>
                      {line}
                      {j < lines.length - 1 && <br />}
                  </React.Fragment>
              ));
           });
      };

      const highlightText = (text, highlight) => {
          if (!text) return text;
          const parts = highlight ? text.split(new RegExp(`(${highlight.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi')) : [text];
          return (
            <React.Fragment>
              {parts.map((part, i) => {
                  if (!part) return null;
                  if (highlight && part.toLowerCase() === highlight.toLowerCase()) {
                      const lines = part.split('\n');
                      const partWithBreaks = lines.map((line, j) => (
                          <React.Fragment key={j}>
                              {line}
                              {j < lines.length - 1 && <br />}
                          </React.Fragment>
                      ));
                      return (
                          <span key={i} className="bg-yellow-200 dark:bg-yellow-800 text-gray-900 dark:text-white rounded-sm">
                              {partWithBreaks}
                          </span>
                      );
                  }
                  return <React.Fragment key={i}>{renderLinksAndTags(part)}</React.Fragment>;
              })}
            </React.Fragment>
          );
      };

      const BulletItem = React.memo((props) => {
          const {
              bullet, level, onUpdate, onAddSibling, onDelete, onIndent, onOutdent,
              onFocusChange, onZoom, onFocusMove, onFocusParent, onFocusChild, onFold, onFoldAll, onMoveBullet,
              currentFocusId, focusPosition, focusMode, searchQuery,
              onTriggerLinkPopup, onCloseLinkPopup, onLinkNavigate, onLinkSelect, isLinkPopupOpen, linkPopupTargetId,
              onTriggerTagPopup, onCloseTagPopup, onTagNavigate, onTagSelect, isTagPopupOpen, tagPopupTargetId,
              onLinkClick, onMerge, onNavigateTo
          } = props;

          const textareaRef = useRef(null);
          const viewRef = useRef(null);
          const containerRef = useRef(null);
          const isFocused = currentFocusId === bullet.id;
          const isEditing = isFocused && focusMode === 'edit';

          useEffect(() => {
              if (isEditing && textareaRef.current) {
                  textareaRef.current.style.height = 'auto';
                  textareaRef.current.style.height = textareaRef.current.scrollHeight + 'px';
              }
          }, [isEditing, bullet.text]);

          useEffect(() => {
              if (isFocused) {
                  if (isEditing && textareaRef.current) {
                      textareaRef.current.focus();
                      if (typeof focusPosition === 'number') {
                          textareaRef.current.setSelectionRange(focusPosition, focusPosition);
                      } else if (focusPosition === 'start') {
                          textareaRef.current.setSelectionRange(0, 0);
                      } else if (focusPosition === 'end') {
                          const len = textareaRef.current.value.length;
                          textareaRef.current.setSelectionRange(len, len);
                      }
                      textareaRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                  } else if (!isEditing && viewRef.current) {
                      requestAnimationFrame(() => {
                          viewRef.current?.focus();
                      });
                  }
              }
          }, [isFocused, isEditing, focusPosition]);

          const handleKeyDown = (e) => {
              if ((isLinkPopupOpen && linkPopupTargetId === bullet.id) || (isTagPopupOpen && tagPopupTargetId === bullet.id)) {
                  if (e.key === 'ArrowUp') {
                      e.preventDefault();
                      if(isLinkPopupOpen) onLinkNavigate('up');
                      else onTagNavigate('up');
                      return;
                  }
                  if (e.key === 'ArrowDown') {
                      e.preventDefault();
                      if(isLinkPopupOpen) onLinkNavigate('down');
                      else onTagNavigate('down');
                      return;
                  }
                  if (e.key === 'Enter' || e.key === 'Tab') {
                      e.preventDefault();
                      if(isLinkPopupOpen) {
                           onLinkSelect((selected) => {
                               insertTextAtCursor(`[[${selected.text}]]`);
                               onCloseLinkPopup();
                           });
                      } else {
                           onTagSelect((selected) => {
                               insertTextAtCursor(selected + ' '); 
                               onCloseTagPopup();
                           });
                      }
                      return;
                  }
                  if (e.key === 'Escape') {
                      e.preventDefault();
                      onCloseLinkPopup();
                      onCloseTagPopup();
                      return;
                  }
              }

              if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  onAddSibling(bullet.id);
              } else if (e.key === 'Backspace' && bullet.text === '' && !bullet.children.length) {
                  e.preventDefault();
                  onDelete(bullet.id);
              } else if (e.key === 'Backspace' && textareaRef.current?.selectionStart === 0 && textareaRef.current?.selectionEnd === 0) {
                  e.preventDefault();
                  onMerge(bullet.id);
              } else if (e.key === 'Tab') {
                  e.preventDefault();
                  if (e.shiftKey) {
                      onOutdent(bullet.id);
                  } else {
                      onIndent(bullet.id);
                  }
              } else if (e.key === 'ArrowUp') {
                  if (e.ctrlKey) {
                      e.preventDefault();
                      onMoveBullet(bullet.id, 'up');
                  } else {
                      e.stopPropagation();
                  }
              } else if (e.key === 'ArrowDown') {
                  if (e.ctrlKey) {
                       e.preventDefault();
                       onMoveBullet(bullet.id, 'down');
                  } else {
                      e.stopPropagation();
                  }
              } else if (e.key === 'Escape') {
                   e.preventDefault();
                   onFocusChange(bullet.id, undefined, 'view');
              }
          };

          const handleViewKeyDown = (e) => {
               if (bullet.isReadOnly) return;
               
               if (e.key === 'Enter') {
                   e.preventDefault();
                   onFocusChange(bullet.id, 'end', 'edit');
                   return;
               }
               
               if (e.key === 'ArrowUp') {
                   if (e.altKey) {
                       e.preventDefault();
                       onMoveBullet(bullet.id, 'up');
                   } else if (e.ctrlKey || e.metaKey) {
                       return;
                   } else {
                       e.preventDefault();
                       onFocusMove('up', undefined, 'view');
                   }
                   return;
               }
               
               if (e.key === 'ArrowDown') {
                   if (e.altKey) {
                       e.preventDefault();
                       onMoveBullet(bullet.id, 'down');
                   } else if (e.ctrlKey || e.metaKey) {
                       e.preventDefault();
                       onZoom(bullet.id);
                   } else {
                       e.preventDefault();
                       onFocusMove('down', undefined, 'view');
                   }
                   return;
               }

               if (e.key === 'ArrowLeft') {
                   e.preventDefault();
                   if (e.ctrlKey) {
                       if (!bullet.isCollapsed && bullet.children.length > 0) {
                          onFoldAll(bullet.id, true);
                       }
                   } else {
                       if (!bullet.isCollapsed && bullet.children.length > 0) {
                           onFold(bullet.id, true);
                       } else {
                           onFocusParent(bullet.id);
                       }
                   }
                   return;
               }

               if (e.key === 'ArrowRight') {
                   e.preventDefault();
                   if (e.ctrlKey) {
                       if (bullet.children.length > 0) {
                          onFoldAll(bullet.id, false);
                       }
                   } else {
                      if (bullet.isCollapsed && bullet.children.length > 0) {
                          onFold(bullet.id, false);
                      } else if (!bullet.isCollapsed && bullet.children.length > 0) {
                          onFocusChild(bullet.id);
                      }
                   }
                   return;
               }
               
               if (e.key === 'Backspace' && bullet.text === '' && bullet.children.length === 0) {
                   e.preventDefault();
                   onDelete(bullet.id);
               }
          };

          const insertTextAtCursor = (textToInsert) => {
              if (!textareaRef.current) return;
              const input = textareaRef.current;
              const text = input.value;
              const cursor = input.selectionStart;
              
              const textBefore = text.substring(0, cursor);
              const linkMatch = textBefore.match(/\[\[([^\]]*)$/);
              const tagMatch = textBefore.match(/#(\w*)$/);

              let newText = text;
              let newCursor = cursor;

              if (isLinkPopupOpen && linkMatch) {
                   const start = linkMatch.index;
                   newText = text.substring(0, start) + textToInsert + text.substring(cursor);
                   newCursor = start + textToInsert.length;
              } else if (isTagPopupOpen && tagMatch) {
                   const start = tagMatch.index;
                   newText = text.substring(0, start) + textToInsert + text.substring(cursor);
                   newCursor = start + textToInsert.length;
              } else {
                   newText = text.substring(0, cursor) + textToInsert + text.substring(cursor);
                   newCursor = cursor + textToInsert.length;
              }

              onUpdate(bullet.id, { text: newText });
              setTimeout(() => {
                   if(textareaRef.current) {
                       textareaRef.current.setSelectionRange(newCursor, newCursor);
                   }
              }, 0);
          };

          const handleChange = (e) => {
              const newText = e.target.value;
              onUpdate(bullet.id, { text: newText });

              const cursor = e.target.selectionStart;
              const textBefore = newText.substring(0, cursor);

              const linkMatch = textBefore.match(/\[\[([^\]]*)$/);
              const tagMatch = textBefore.match(/#(\w*)$/);

              if (linkMatch) {
                   onTriggerLinkPopup(bullet.id, linkMatch[1], textareaRef, (selected) => {
                       insertTextAtCursor(`[[${selected.text}]]`);
                       onCloseLinkPopup();
                   });
              } else {
                   onCloseLinkPopup();
              }

              if (tagMatch) {
                  onTriggerTagPopup(bullet.id, tagMatch[1], textareaRef, (selected) => {
                      insertTextAtCursor(selected + ' ');
                      onCloseTagPopup();
                  });
              } else {
                  onCloseTagPopup();
              }
          };
          
          const handleViewClick = (e) => {
               const target = e.target;
               if (target.tagName === 'SPAN' && (target.innerText.startsWith('[[') || target.innerText.startsWith('#'))) {
                   onLinkClick(target.innerText.replace(/[\[\]]/g, ''));
                   return;
               }
               
               if (!isEditing && !bullet.isReadOnly) {
                   onFocusChange(bullet.id, undefined, 'edit');
               }
          };

          return (
              <div className="relative group" ref={containerRef}>
                  <div className={`flex items-start py-1 rounded transition-colors ${isFocused && !isEditing ? 'bg-blue-50 dark:bg-gray-800' : ''}`}>
                      <div className="flex-shrink-0 w-6 h-6 flex items-center justify-center mr-1 mt-0.5 relative z-10 select-none">
                          <div 
                              className="cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-700 rounded-full p-0.5 transition-colors focus:outline-none"
                              onClick={(e) => { e.stopPropagation(); onZoom(bullet.id); }}
                              onMouseDown={(e) => e.preventDefault()}
                              tabIndex={-1}
                          >
                               <CircleIcon className="w-2 h-2 text-[var(--main-color)]" />
                          </div>
                           <div 
                              className="absolute -left-6 cursor-pointer text-gray-400 hover:text-gray-600 dark:hover:text-gray-200 p-1 focus:outline-none"
                              onClick={(e) => { e.stopPropagation(); onFold(bullet.id, !bullet.isCollapsed); }}
                              onMouseDown={(e) => e.preventDefault()}
                              tabIndex={-1}
                          >
                              {bullet.children.length > 0 && (
                                  bullet.isCollapsed ? <ChevronRightIcon /> : <ChevronDownIcon />
                              )}
                          </div>
                      </div>

                      <div className="flex-grow min-w-0 relative">
                          {isEditing ? (
                              <textarea
                                  ref={textareaRef}
                                  value={bullet.text}
                                  onChange={handleChange}
                                  onKeyDown={handleKeyDown}
                                  className="w-full resize-none bg-transparent outline-none p-0 m-0 text-base leading-relaxed text-gray-900 dark:text-gray-100 font-[family-name:var(--font-family)]"
                                  rows={1}
                                  placeholder="Type here..."
                                  readOnly={bullet.isReadOnly}
                              />
                          ) : (
                              <div 
                                  ref={viewRef}
                                  className={`text-base leading-relaxed text-gray-900 dark:text-gray-100 min-h-[24px] cursor-text break-words font-[family-name:var(--font-family)] outline-none ${isFocused ? 'ring-2 ring-opacity-20 ring-[var(--main-color)] rounded-sm' : ''}`}
                                  onClick={handleViewClick}
                                  onKeyDown={handleViewKeyDown}
                                  tabIndex={0}
                              >
                                  {highlightText(bullet.text, searchQuery) || <span className="text-gray-400 italic">Empty</span>}
                              </div>
                          )}
                      </div>
                  </div>

                  {!bullet.isCollapsed && bullet.children.length > 0 && (
                      <div className="ml-6 border-l border-gray-200 dark:border-gray-700 pl-2">
                          {bullet.children.map(child => (
                              <BulletItem
                                  key={child.id}
                                  bullet={child}
                                  level={level + 1}
                                  onUpdate={onUpdate}
                                  onAddSibling={onAddSibling}
                                  onDelete={onDelete}
                                  onIndent={onIndent}
                                  onOutdent={onOutdent}
                                  onFocusChange={onFocusChange}
                                  onZoom={onZoom}
                                  onFocusMove={onFocusMove}
                                  onFocusParent={onFocusParent}
                                  onFocusChild={onFocusChild}
                                  onFold={onFold}
                                  onFoldAll={onFoldAll}
                                  onMoveBullet={onMoveBullet}
                                  currentFocusId={currentFocusId}
                                  focusPosition={focusPosition}
                                  focusMode={focusMode}
                                  searchQuery={searchQuery}
                                  onLinkClick={onLinkClick}
                                  onTriggerLinkPopup={onTriggerLinkPopup}
                                  onCloseLinkPopup={onCloseLinkPopup}
                                  onLinkNavigate={onLinkNavigate}
                                  onLinkSelect={onLinkSelect}
                                  isLinkPopupOpen={isLinkPopupOpen}
                                  linkPopupTargetId={linkPopupTargetId}
                                  onTriggerTagPopup={onTriggerTagPopup}
                                  onCloseTagPopup={onCloseTagPopup}
                                  onTagNavigate={onTagNavigate}
                                  onTagSelect={onTagSelect}
                                  isTagPopupOpen={isTagPopupOpen}
                                  tagPopupTargetId={tagPopupTargetId}
                                  isJournalRoot={false}
                                  onNavigateTo={onNavigateTo}
                                  onMerge={onMerge}
                              />
                          ))}
                      </div>
                  )}
              </div>
          );
      });
      
      const FONT_LIST = [
        'Arial', 'Verdana', 'Helvetica', 'Tahoma', 'Trebuchet MS', 
        'Times New Roman', 'Georgia', 'Garamond', 
        'Courier New', 'Brush Script MT', 'sans-serif', 'serif', 'monospace'
      ];

      const SettingsModal = ({ isOpen, onClose, onSave, currentSettings, onClearData }) => {
          const [settings, setSettings] = useState(currentSettings);

          useEffect(() => {
              setSettings(currentSettings);
          }, [isOpen, currentSettings]);

          const handleSave = () => {
              onSave(settings);
              onClose();
          };
          
          const handleInputChange = (e) => {
              const { name, value } = e.target;
              setSettings(prev => ({...prev, [name]: value }));
          };

          const handleFontSizeChange = (e) => {
              setSettings(prev => ({...prev, fontSize: parseInt(e.target.value, 10) }));
          }

          if (!isOpen) return null;

          return (
              <div className="fixed inset-0 bg-black/60 z-30 flex justify-center items-center" onClick={onClose}>
                  <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-md" onClick={e => e.stopPropagation()}>
                      <h2 className="p-4 text-lg font-semibold border-b border-gray-200 dark:border-gray-700">Settings</h2>
                      <div className="p-4 space-y-4">
                          <div>
                              <label htmlFor="fileName" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">File Name</label>
                              <input type="text" id="fileName" name="fileName" value={settings.fileName} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"/>
                          </div>
                          <div>
                              <label htmlFor="mainColor" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Main Color</label>
                              <input type="color" id="mainColor" name="mainColor" value={settings.mainColor} onChange={handleInputChange} className="w-full h-10 p-1 bg-gray-100 dark:bg-gray-700 rounded-md cursor-pointer"/>
                          </div>
                          <div>
                              <label htmlFor="fontFamily" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font</label>
                              <select id="fontFamily" name="fontFamily" value={settings.fontFamily} onChange={handleInputChange} className="w-full bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-3 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]">
                                  {FONT_LIST.map(font => <option key={font} value={font}>{font}</option>)}
                              </select>
                          </div>
                          <div>
                              <label htmlFor="fontSize" className="block text-sm font-medium text-gray-500 dark:text-gray-400 mb-1">Font Size ({settings.fontSize}px)</label>
                              <input type="range" id="fontSize" name="fontSize" min="12" max="24" value={settings.fontSize} onChange={handleFontSizeChange} className="w-full"/>
                          </div>

                          <div className="pt-4 border-t border-gray-200 dark:border-gray-700">
                              <h3 className="text-sm font-medium text-red-600 dark:text-red-400 mb-2">Data Management</h3>
                              <button 
                                  onClick={onClearData}
                                  className="flex items-center gap-2 px-4 py-2 text-sm font-medium text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900/20 hover:bg-red-100 dark:hover:bg-red-900/30 rounded-md transition-colors w-full justify-center"
                              >
                                  <TrashIcon className="w-4 h-4" />
                                  Reset Application Data
                              </button>
                              <p className="mt-1 text-xs text-gray-500 dark:text-gray-400 text-center">
                                  Deletes all local data and restores the default template.
                              </p>
                          </div>
                      </div>
                      <div className="p-4 flex justify-end gap-2 border-t border-gray-200 dark:border-gray-700">
                          <button onClick={onClose} className="px-4 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-600 dark:hover:bg-gray-500 dark:text-white">Cancel</button>
                          <button onClick={handleSave} className="px-4 py-2 rounded-md bg-[var(--main-color)] text-white hover:opacity-90">Save</button>
                      </div>
                  </div>
              </div>
          );
      }
      
      const SearchModal = ({ isOpen, onClose, bullets, onNavigate, initialQuery }) => {
          const [query, setQuery] = useState('');
          const [selectedIndex, setSelectedIndex] = useState(0);
          const [activeTab, setActiveTab] = useState('search');
          const inputRef = useRef(null);
          const listRef = useRef(null);
          const selectedItemRef = useRef(null);
          const tagPopupRef = useRef(null);

          const [tagPopupState, setTagPopupState] = useState({
            isOpen: false,
            suggestions: [],
            selectedIndex: 0,
          });

          const flatBullets = useMemo(() => {
              if (!isOpen) return [];
              
              const results = [];
              const traverse = (nodes, currentPath) => {
                  for (const node of nodes) {
                      results.push({
                          id: node.id,
                          text: node.text,
                          path: currentPath,
                          createdAt: node.createdAt,
                          updatedAt: node.updatedAt,
                      });
                      if (node.children && node.children.length > 0) {
                          traverse(node.children, [...currentPath, node.text || 'Untitled']);
                      }
                  }
              };
              traverse(bullets, []);
              return results;
          }, [bullets, isOpen]);

          const allTags = useMemo(() => {
              if (!isOpen) return [];
              const tagSet = new Set();
              const tagRegex = /#\w+/g;
              for (const bullet of flatBullets) {
                  const matches = bullet.text.match(tagRegex);
                  if (matches) {
                      matches.forEach(tag => tagSet.add(tag));
                  }
              }
              return Array.from(tagSet).sort();
          }, [flatBullets, isOpen]);

          useEffect(() => {
            if (isOpen) {
              inputRef.current?.focus();
              setQuery(initialQuery || '');
              setSelectedIndex(0);
              setActiveTab('search');
              handleCloseTagPopup();
            }
          }, [isOpen, initialQuery]);
          
          useEffect(() => {
            setSelectedIndex(0);
          }, [query, activeTab]);

          const listContent = useMemo(() => {
            let sourceList;
            
            if (activeTab === 'edited') {
                sourceList = [...flatBullets].sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0));
            } else if (activeTab === 'created') {
                sourceList = [...flatBullets].sort((a, b) => (b.createdAt || 0) - (a.createdAt || 0));
            } else {
                sourceList = flatBullets;
            }

            const trimmedQuery = query.trim();
            if (!trimmedQuery) {
              return sourceList;
            }

            const lowerCaseQuery = trimmedQuery.toLowerCase();
            const orClauses = lowerCaseQuery.split(/\s+or\s+/i);
            const searchConditionGroups = orClauses.map(clause => 
                clause.split(/\s+/).filter(term => term)
            );

            return sourceList.filter(bullet => {
                const lowerCaseText = bullet.text.toLowerCase();
                return searchConditionGroups.some(andTerms => {
                    return andTerms.every(term => lowerCaseText.includes(term));
                });
            });
          }, [query, flatBullets, activeTab]);

          useEffect(() => {
            if (selectedItemRef.current) {
              selectedItemRef.current.scrollIntoView({ block: 'nearest' });
            }
          }, [selectedIndex]);

          const handleCloseTagPopup = useCallback(() => {
            setTagPopupState(prev => (prev.isOpen ? { ...prev, isOpen: false } : prev));
          }, []);

          const handleTagSelection = useCallback((selectedTag) => {
            const input = inputRef.current;
            if (!input) return;

            const text = input.value;
            const cursor = input.selectionStart ?? text.length;

            const textBeforeCursor = text.substring(0, cursor);
            const match = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);

            if (match) {
                const startIndex = match.index + (match[0].startsWith(' ') ? 1 : 0);
                const newText = text.substring(0, startIndex) + selectedTag + ' ' + text.substring(cursor);
                setQuery(newText);
                handleCloseTagPopup();

                setTimeout(() => {
                    const newCursorPos = startIndex + selectedTag.length + 1;
                    input.focus();
                    input.setSelectionRange(newCursorPos, newCursorPos);
                }, 0);
            }
          }, [handleCloseTagPopup]);

          const handleQueryChange = (e) => {
            const text = e.target.value;
            const cursor = e.target.selectionStart;
            setQuery(text);

            if (cursor === null) {
              handleCloseTagPopup();
              return;
            }

            const textBeforeCursor = text.substring(0, cursor);
            const tagMatch = textBeforeCursor.match(/(?:\s|^)#(\w*)$/);
            
            if (tagMatch) {
                const query = tagMatch[1];
                const lowerCaseQuery = query.toLowerCase();
                const suggestions = allTags.filter(tag => tag.toLowerCase().includes(lowerCaseQuery));

                if (suggestions.length > 0) {
                    setTagPopupState({
                        isOpen: true,
                        suggestions: suggestions.slice(0, 100),
                        selectedIndex: 0,
                    });
                } else {
                    handleCloseTagPopup();
                }
            } else {
                handleCloseTagPopup();
            }
          };

          const handleKeyDown = (e) => {
            if (tagPopupState.isOpen && tagPopupState.suggestions.length > 0) {
                let handled = true;
                switch (e.key) {
                    case 'ArrowUp':
                        setTagPopupState(prev => ({
                            ...prev,
                            selectedIndex: (prev.selectedIndex - 1 + prev.suggestions.length) % prev.suggestions.length,
                        }));
                        break;
                    case 'ArrowDown':
                        setTagPopupState(prev => ({
                            ...prev,
                            selectedIndex: (prev.selectedIndex + 1) % prev.suggestions.length,
                        }));
                        break;
                    case 'Tab':
                        const selectedTag = tagPopupState.suggestions[tagPopupState.selectedIndex];
                        handleTagSelection(selectedTag);
                        break;
                    case 'Escape':
                        handleCloseTagPopup();
                        break;
                    default:
                        handled = false;
                }
                if (handled) {
                    e.preventDefault();
                    return;
                }
            }

            if (e.ctrlKey) {
                const tabs = ['search', 'edited', 'created'];
                const currentIndex = tabs.indexOf(activeTab);
                let handled = true;

                if (e.key === 'ArrowRight') {
                    const nextIndex = (currentIndex + 1) % tabs.length;
                    setActiveTab(tabs[nextIndex]);
                } else if (e.key === 'ArrowLeft') {
                    const nextIndex = (currentIndex - 1 + tabs.length) % tabs.length;
                    setActiveTab(tabs[nextIndex]);
                } else {
                    handled = false;
                }

                if (handled) {
                    e.preventDefault();
                    return;
                }
            }

            const count = listContent.length;
            if (e.key === 'Escape') {
              onClose();
              return;
            }

            if (count === 0 && e.key !== 'Enter') return;

            if (e.key === 'ArrowDown') {
              e.preventDefault();
              setSelectedIndex(prev => (prev + 1) % count);
            } else if (e.key === 'ArrowUp') {
              e.preventDefault();
              setSelectedIndex(prev => (prev - 1 + count) % count);
            } else if (e.key === 'Enter') {
              e.preventDefault();
              if (listContent.length > 0 && listContent[selectedIndex]) {
                onNavigate(listContent[selectedIndex].id);
              }
            }
          };

          const highlightMatch = (text, q) => {
              const trimmedQuery = q.trim();
              if (!trimmedQuery || !text) return text;
              const termsToHighlight = trimmedQuery.toLowerCase().replace(/\s+or\s+/gi, ' ').split(/\s+/).filter(Boolean);
              const uniqueTerms = [...new Set(termsToHighlight)];
              if (uniqueTerms.length === 0) return text;
              const regex = new RegExp(`(${uniqueTerms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('|')})`, 'gi');
              const parts = text.split(regex);
              return (
                  <span>
                      {parts.map((part, i) => {
                          if (part && uniqueTerms.some(term => term === part.toLowerCase())) {
                              return <span key={i} className="bg-yellow-400/40 dark:bg-yellow-600/40 rounded-sm">{part}</span>;
                          }
                          return part;
                      })}
                  </span>
              );
          };

          const formatDateTime = (timestamp) => {
            if (!timestamp) return '';
            const date = new Date(timestamp);
            return date.toLocaleString(undefined, {
              year: 'numeric', month: 'short', day: 'numeric',
              hour: 'numeric', minute: '2-digit', hour12: false,
            });
          };

          if (!isOpen) return null;

          return (
            <div
              className="fixed inset-0 bg-black/40 dark:bg-black/60 z-30 flex justify-center items-start pt-20"
              onClick={onClose}
            >
              <div
                className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[70vh] flex flex-col"
                onClick={e => e.stopPropagation()}
              >
                <div className="p-4 border-b border-gray-200 dark:border-gray-700 text-[var(--main-color)]">
                    <div className="relative">
                        <span className="absolute inset-y-0 left-0 flex items-center pl-3">
                            <SearchIcon />
                        </span>
                        <input
                            ref={inputRef}
                            type="text"
                            placeholder="Quick find... (use #tag, AND, OR)"
                            value={query}
                            onChange={handleQueryChange}
                            onKeyDown={handleKeyDown}
                            className="w-full bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 pl-10 pr-4 py-2 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--main-color)]"
                        />
                         {tagPopupState.isOpen && inputRef.current && (
                            <TagPopup
                                suggestions={tagPopupState.suggestions}
                                selectedIndex={tagPopupState.selectedIndex}
                                onSelect={handleTagSelection}
                                position={{
                                    top: inputRef.current.offsetHeight + 4,
                                    left: 0
                                }}
                                containerRef={tagPopupRef}
                            />
                        )}
                    </div>
                    <div className="mt-3 flex border-b border-gray-200 dark:border-gray-700 text-sm">
                        {['search', 'edited', 'created'].map(tab => (
                            <button
                                key={tab}
                                onClick={() => setActiveTab(tab)}
                                className={`px-4 py-2 capitalize -mb-px border-b-2 transition-colors ${
                                    activeTab === tab 
                                        ? 'border-[var(--main-color)] text-[var(--main-color)]' 
                                        : 'border-transparent text-gray-500 hover:text-gray-800 dark:hover:text-gray-200'
                                }`}
                            >
                                {tab === 'edited' ? 'Recently modified' : (tab === 'created' ? 'Recently created' : 'Search')}
                            </button>
                        ))}
                    </div>
                </div>

                <div className="overflow-y-auto">
                  {listContent.length > 0 ? (
                    <ul ref={listRef}>
                      {listContent.map((bullet, index) => (
                        <li
                          key={bullet.id}
                          ref={index === selectedIndex ? selectedItemRef : null}
                          className={`cursor-pointer transition-colors duration-75 ${index === selectedIndex ? 'selected-item-bg text-white' : 'hover:bg-gray-100 dark:hover:bg-gray-700'}`}
                          onClick={() => onNavigate(bullet.id)}
                        >
                          <div className="px-4 py-2 border-b border-gray-200/50 dark:border-gray-700/50">
                            <div className="flex justify-between items-start gap-4">
                                <div className={`text-sm font-medium truncate mb-1 flex-grow ${index === selectedIndex ? 'text-white' : 'text-gray-800 dark:text-gray-200'}`}>
                                    {highlightMatch(bullet.text, query) || <em>Untitled</em>}
                                </div>
                                <div className={`text-xs flex-shrink-0 whitespace-nowrap ${index === selectedIndex ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'}`}>
                                    {formatDateTime(activeTab === 'created' ? bullet.createdAt : bullet.updatedAt)}
                                </div>
                            </div>
                            <div className={`text-xs flex flex-wrap items-center gap-1 leading-none ${
                                index === selectedIndex ? 'text-white/80' : 'text-gray-500 dark:text-gray-400'
                            }`}>
                                {bullet.path.length > 0 ? (
                                    bullet.path.map((segment, i) => (
                                        <React.Fragment key={i}>
                                            <span className="truncate max-w-[200px]" title={segment}>{segment}</span>
                                            {i < bullet.path.length - 1 && (
                                                <span className="opacity-50 flex-shrink-0">/</span>
                                            )}
                                        </React.Fragment>
                                    ))
                                ) : (
                                     <span className="italic opacity-50">Top level</span>
                                )}
                            </div>
                          </div>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="text-gray-400 dark:text-gray-500 p-4 text-center">No results found.</p>
                  )}
                </div>
              </div>
            </div>
          );
      };
      
      class JaroetDatabase extends Dexie {
        constructor() {
          super("JaroetOutlinerDB");
          this.version(1).stores({
              keyValuePairs: 'key', 
          });
          this.keyValuePairs = this.table('keyValuePairs');
        }
      }
      const db = new JaroetDatabase();

      const DAILY_LOG_ROOT_TEXT = 'Daily Log';
      const initialData = [
        {
          id: 'journal-root',
          text: DAILY_LOG_ROOT_TEXT,
          children: [],
          isCollapsed: true,
        },
        {
          id: 'help-info',
          text: 'For help and documentation, import the jr_help-documentation.json file.',
          children: [],
          isCollapsed: false,
        }
      ];

      const createNewBullet = (text = '') => ({
          id: crypto.randomUUID(),
          text,
          children: [],
          isCollapsed: false,
          createdAt: Date.now(),
          updatedAt: Date.now(),
      });
      
      const migrateBullets = (nodes) => {
          if (!Array.isArray(nodes)) return [];
          const now = Date.now();
          return nodes.map(node => ({
              ...node,
              createdAt: node.createdAt || now,
              updatedAt: node.updatedAt || now,
              children: migrateBullets(node.children || []),
          }));
      };

      const regenerateIds = (nodes) => {
          if (!Array.isArray(nodes)) return [];
          return nodes.map(node => ({
              ...node,
              id: crypto.randomUUID(),
              children: regenerateIds(node.children || []),
          }));
      };
      
      const mapBullets = (nodes, callback) => {
          let changed = false;
          const newNodes = nodes.map(node => {
              const newNode = callback(node);
              const newChildren = mapBullets(newNode.children, callback);
              if (newNode === node && newChildren === node.children) {
                  return node;
              }
              changed = true;
              return { ...newNode, children: newChildren };
          });
          return changed ? newNodes : nodes;
      };

      const App = () => {
          const [bullets, setBullets] = useState(initialData);
          const [zoomedBulletId, setZoomedBulletId] = useState(null);
          const [focusOptions, setFocusOptions] = useState({ id: null, position: 'end', mode: 'view' });
          const isInitialFocusSet = useRef(false);
          const linkPopupRef = useRef(null);
          const tagPopupRef = useRef(null);
          const [isSearchModalOpen, setIsSearchModalOpen] = useState(false);
          const [searchQuery, setSearchQuery] = useState('');
          const [linkSelectionHandler, setLinkSelectionHandler] = useState({ handler: null });
          const [tagSelectionHandler, setTagSelectionHandler] = useState({ handler: null });
          const prevFocusId = useRef(null);
          const dataLoadedRef = useRef(false);
          const prevCoreDataRef = useRef(null);
          const [theme, setTheme] = useState('dark');
          const [isSidebarOpen, setIsSidebarOpen] = useState(false);
          const [recentBullets, setRecentBullets] = useState([]);
          const [favoriteBullets, setFavoriteBullets] = useState([]);
          const { toasts, addToast, removeToast } = useToast();
          const [settings, setSettings] = useState({
              mainColor: '#60a5fa',
              fileName: 'My Outline',
              fontFamily: 'sans-serif',
              fontSize: 16,
          });
          const [isSettingsModalOpen, setIsSettingsModalOpen] = useState(false);
          const [pendingImportData, setPendingImportData] = useState(null);
          const [isImportModalOpen, setIsImportModalOpen] = useState(false);
          const [linkPopupState, setLinkPopupState] = useState({
              isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0
          });
          const [tagPopupState, setTagPopupState] = useState({
              isOpen: false, targetId: null, query: '', position: { top: 0, left: 0 }, suggestions: [], selectedIndex: 0
          });

          const currentFocusId = focusOptions.id;
          const focusPosition = focusOptions.position;
          const focusMode = focusOptions.mode;

          const handleFocusChange = useCallback((id, position = 'end', mode = 'view') => {
              setFocusOptions({ id, position, mode });
          }, []);

          const getCoreDataString = useCallback((nodes) => {
              const removeUiState = (b) => ({
                  id: b.id,
                  text: b.text,
                  children: b.children.map(removeUiState),
                  originalId: b.originalId,
                  isFavorite: b.isFavorite,
                  createdAt: b.createdAt,
                  updatedAt: b.updatedAt,
              });
              return JSON.stringify(nodes.map(removeUiState));
          }, []);

          const handleThemeToggle = useCallback(() => {
              const newTheme = theme === 'light' ? 'dark' : 'light';
              setTheme(newTheme);
              db.keyValuePairs.put({ key: 'theme', value: newTheme });
              addToast(`Switched to ${newTheme} mode`, 'info');
          }, [theme, addToast]);

          useEffect(() => {
              document.documentElement.classList.toggle('dark', theme === 'dark');
          }, [theme]);

          const updateRecentList = useCallback((id, text, updatedAt) => {
              setRecentBullets(prev => {
                  const newList = prev.filter(item => item.id !== id);
                  let itemText = text;
                  if (itemText === undefined) {
                      const existing = prev.find(i => i.id === id);
                      if (existing) itemText = existing.text;
                      else return prev;
                  }
                  newList.unshift({ id, text: itemText, updatedAt });
                  return newList.slice(0, 12);
              });
          }, []);

          const removeFromRecentList = useCallback((id) => {
              setRecentBullets(prev => prev.filter(item => item.id !== id));
              setFavoriteBullets(prev => prev.filter(item => item.id !== id));
          }, []);

          useEffect(() => {
              const loadData = async () => {
                  const savedThemeEntry = await db.keyValuePairs.get('theme');
                  if (savedThemeEntry?.value) setTheme(savedThemeEntry.value);

                  try {
                      const savedSidebar = await db.keyValuePairs.get('isSidebarOpen');
                      if (savedSidebar !== undefined) setIsSidebarOpen(savedSidebar.value);
                  } catch (e) {}
                  
                  try {
                      const savedRecents = await db.keyValuePairs.get('recentBullets');
                      if (savedRecents?.value) setRecentBullets(savedRecents.value);
                      
                      const savedFavorites = await db.keyValuePairs.get('favoriteBullets');
                      if (savedFavorites?.value) setFavoriteBullets(savedFavorites.value);
                  } catch (e) {}

                  let loadedSettings;
                  const defaultSettings = {
                      mainColor: '#60a5fa',
                      fileName: 'My Outline',
                      fontFamily: 'sans-serif',
                      fontSize: 16,
                  };
                  try {
                      const savedSettingsEntry = await db.keyValuePairs.get('settings');
                      loadedSettings = { ...defaultSettings, ...(savedSettingsEntry?.value || {}) };
                      setSettings(loadedSettings);
                  } catch (error) {
                      loadedSettings = defaultSettings;
                  }

                  let localBullets = null;
                  try {
                      const savedDataEntry = await db.keyValuePairs.get('bullets');
                      if (savedDataEntry?.value) localBullets = savedDataEntry.value;
                  } catch(e) {}
                  
                  let initialLoadData = migrateBullets(localBullets || initialData);

                  setBullets(initialLoadData);
                  prevCoreDataRef.current = getCoreDataString(initialLoadData);
                  setZoomedBulletId(null);
                  isInitialFocusSet.current = false;
                  dataLoadedRef.current = true;
              };
              loadData();
          }, [getCoreDataString]);

          useEffect(() => {
              if (!dataLoadedRef.current) return;
              db.keyValuePairs.put({ key: 'settings', value: settings });
              document.title = `${settings.fileName || 'Untitled'} - JaRoet Outliner`;
              document.documentElement.style.setProperty('--main-color', settings.mainColor);
              document.documentElement.style.setProperty('--font-family', settings.fontFamily);
              document.documentElement.style.setProperty('--font-size', `${settings.fontSize}px`);
              db.keyValuePairs.put({ key: 'bullets', value: bullets });
              
              const currentCoreData = getCoreDataString(bullets);
              if (currentCoreData !== prevCoreDataRef.current) {
                   prevCoreDataRef.current = currentCoreData;
              }
          }, [settings, bullets, getCoreDataString]);
          
          useEffect(() => {
              if (dataLoadedRef.current) db.keyValuePairs.put({ key: 'recentBullets', value: recentBullets });
          }, [recentBullets]);

          useEffect(() => {
              if (dataLoadedRef.current) db.keyValuePairs.put({ key: 'favoriteBullets', value: favoriteBullets });
          }, [favoriteBullets]);

          const findBulletAndParent = useCallback((id, nodes, parent = null) => {
              for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node.id === id) return { node, parent, siblings: nodes, index: i };
                const found = findBulletAndParent(id, node.children, node);
                if (found) return found;
              }
              return null;
          }, []);

          useEffect(() => {
              const currentId = focusOptions.id;
              const prevId = prevFocusId.current;
              if (prevId && prevId !== currentId) {
                  const found = findBulletAndParent(prevId, bullets);
                  if (found && !found.node.isReadOnly && found.node.text === '' && found.node.children.length === 0) {
                      const newBullets = structuredClone(bullets);
                      const foundAgain = findBulletAndParent(prevId, newBullets);
                      if (foundAgain) {
                          foundAgain.siblings.splice(foundAgain.index, 1);
                          setBullets(newBullets);
                          removeFromRecentList(prevId);
                      }
                  }
              }
              prevFocusId.current = currentId;
          }, [focusOptions.id, bullets, findBulletAndParent, removeFromRecentList]);

          const breadcrumbs = useMemo(() => {
              if (!zoomedBulletId) return [];
              const path = [];
              const findPath = (nodes, currentPath) => {
                  for (const node of nodes) {
                      const newPath = [...currentPath, node];
                      if (node.id === zoomedBulletId) {
                          path.push(...newPath);
                          return true;
                      }
                      if (findPath(node.children, newPath)) return true;
                  }
                  return false;
              };
              findPath(bullets, []);
              return path;
          }, [bullets, zoomedBulletId]);
          
          const handleNavigate = useCallback((bulletId) => {
              const path = [];
              const findPath = (nodes, currentPath) => {
                  for (const node of nodes) {
                      const newPath = [...currentPath, node];
                      if (node.id === bulletId) {
                          path.push(...newPath);
                          return true;
                      }
                      if (findPath(node.children, newPath)) return true;
                  }
                  return false;
              };
              findPath(bullets, []);
              if (path.length > 0) {
                  const parent = path.length > 1 ? path[path.length - 2] : null;
                  setZoomedBulletId(parent ? parent.id : null);
                  setIsSearchModalOpen(false);
                  setSearchQuery('');
                  setTimeout(() => {
                      handleFocusChange(bulletId, 'end', 'view');
                  }, 0);
              }
          }, [bullets, handleFocusChange]);

          const displayedBullets = useMemo(() => {
              if (!zoomedBulletId) return bullets;
              const findZoomed = (nodes) => {
                  for (const node of nodes) {
                      if (node.id === zoomedBulletId) return node;
                      const found = findZoomed(node.children);
                      if (found) return found;
                  }
                  return null;
              }
              const zoomedNode = findZoomed(bullets);
              return zoomedNode ? zoomedNode.children : [];
          }, [bullets, zoomedBulletId]);

          const targetFavoriteId = currentFocusId || zoomedBulletId;
          const isTargetFavorite = useMemo(() => {
              if (!targetFavoriteId) return false;
              const findBullet = (nodes) => {
                  for (const node of nodes) {
                      if (node.id === targetFavoriteId) return node;
                      const found = findBullet(node.children);
                      if (found) return found;
                  }
                  return null;
              }
              const node = findBullet(bullets);
              return node?.isFavorite || false;
          }, [bullets, targetFavoriteId]);

          const handleToggleFavorite = useCallback(() => {
              if (!targetFavoriteId) return;
              setBullets(prev => {
                  let isNowFav = false;
                  let targetText = '';
                  const newBullets = mapBullets(prev, b => {
                      if (b.id === targetFavoriteId) {
                          isNowFav = !b.isFavorite;
                          targetText = b.text;
                          return { ...b, isFavorite: isNowFav };
                      }
                      return b;
                  });
                  setFavoriteBullets(currentFavs => {
                      if (isNowFav) {
                          if (currentFavs.some(f => f.id === targetFavoriteId)) return currentFavs;
                          return [...currentFavs, { id: targetFavoriteId, text: targetText }];
                      } else {
                          return currentFavs.filter(f => f.id !== targetFavoriteId);
                      }
                  });
                  if (isNowFav) addToast('Added to favorites', 'success');
                  else addToast('Removed from favorites', 'info');
                  return newBullets;
              });
          }, [targetFavoriteId, addToast]);

          const visibleBulletIds = useMemo(() => {
              const getVisibleIds = (nodes) => {
                  let ids = [];
                  for (const node of nodes) {
                      ids.push(node.id);
                      if (!node.isCollapsed && node.children.length > 0) {
                          ids = ids.concat(getVisibleIds(node.children));
                      }
                  }
                  return ids;
              };
              return getVisibleIds(displayedBullets);
          }, [displayedBullets]);
          
          const bulletsRef = useRef(bullets);
          const visibleBulletIdsRef = useRef(visibleBulletIds);
          const zoomedBulletIdRef = useRef(zoomedBulletId);
          const focusOptionsRef = useRef(focusOptions);
          const breadcrumbsRef = useRef(breadcrumbs);

          useEffect(() => { bulletsRef.current = bullets; }, [bullets]);
          useEffect(() => { visibleBulletIdsRef.current = visibleBulletIds; }, [visibleBulletIds]);
          useEffect(() => { zoomedBulletIdRef.current = zoomedBulletId; }, [zoomedBulletId]);
          useEffect(() => { focusOptionsRef.current = focusOptions; }, [focusOptions]);
          useEffect(() => { breadcrumbsRef.current = breadcrumbs; }, [breadcrumbs]);

          useEffect(() => {
              if (!isInitialFocusSet.current && visibleBulletIds.length > 0) {
                  handleFocusChange(visibleBulletIds[0], 'end', 'view');
                  isInitialFocusSet.current = true;
              }
          }, [visibleBulletIds, handleFocusChange]);
          
          const handleZoom = useCallback((id) => {
              const currentBullets = bulletsRef.current;
              const oldZoomedBulletId = zoomedBulletIdRef.current;
              const currentBreadcrumbs = breadcrumbsRef.current;
              const isZoomingOut = (id === null && oldZoomedBulletId !== null) || 
                                   (id !== null && currentBreadcrumbs.some(b => b.id === id));
              if (id === null) { 
                  setZoomedBulletId(null);
                  if (oldZoomedBulletId) {
                      setTimeout(() => handleFocusChange(oldZoomedBulletId, 'end', 'view'), 0);
                  } else {
                      const getVisibleIds = (nodes) => {
                          let ids = [];
                          for (const node of nodes) {
                              ids.push(node.id);
                              if (!node.isCollapsed && node.children.length > 0) {
                                  ids = ids.concat(getVisibleIds(node.children));
                              }
                          }
                          return ids;
                      };
                      const rootVisibleIds = getVisibleIds(currentBullets);
                      if (rootVisibleIds.length > 0) handleFocusChange(rootVisibleIds[0], 'end', 'view');
                  }
                  return;
              }
              const find = (nodes) => {
                  for(const node of nodes) {
                      if (node.id === id) return node;
                      const f = find(node.children);
                      if (f) return f;
                  }
                  return null;
              };
              const bulletToZoom = find(currentBullets);
              if (bulletToZoom && bulletToZoom.children.length === 0 && !bulletToZoom.isReadOnly) {
                  const newBullet = createNewBullet();
                  setBullets(prevBullets => {
                      const newBullets = structuredClone(prevBullets);
                      const found = findBulletAndParent(id, newBullets);
                      if (found) {
                          found.node.children.push(newBullet);
                          found.node.isCollapsed = false;
                          return newBullets;
                      }
                      return prevBullets;
                  });
                  setZoomedBulletId(id);
                  setTimeout(() => {
                      handleFocusChange(newBullet.id, 'start', 'edit'); 
                  }, 0);
                  updateRecentList(newBullet.id, newBullet.text, newBullet.updatedAt || Date.now());
              } else if (bulletToZoom) {
                  setZoomedBulletId(id);
                  if (isZoomingOut && oldZoomedBulletId) {
                      setTimeout(() => handleFocusChange(oldZoomedBulletId, 'end', 'view'), 0);
                  } else if (bulletToZoom.children.length > 0) {
                       const getVisibleIds = (nodes) => {
                          let ids = [];
                          for (const node of nodes) {
                              ids.push(node.id);
                              if (!node.isCollapsed && node.children.length > 0) {
                                  ids = ids.concat(getVisibleIds(node.children));
                              }
                          }
                          return ids;
                      };
                      const visibleChildrenIds = getVisibleIds(bulletToZoom.children);
                      if (visibleChildrenIds.length > 0) handleFocusChange(visibleChildrenIds[0], 'end', 'view');
                  }
              }
          }, [handleFocusChange, findBulletAndParent, updateRecentList]);

          const handleGoToJournal = useCallback(() => {
              const now = new Date();
              const year = now.getFullYear().toString();
              const month = (now.getMonth() + 1).toString().padStart(2, '0');
              const day = now.getDate().toString().padStart(2, '0');
              const dayText = `${year}-${month}-${day}`;
              const currentBullets = bulletsRef.current;
              const newBullets = structuredClone(currentBullets);
              let journalNode = newBullets.find((b) => b.text === DAILY_LOG_ROOT_TEXT);
              if (!journalNode) {
                  journalNode = createNewBullet(DAILY_LOG_ROOT_TEXT);
                  newBullets.unshift(journalNode);
              }
              let yearNode = journalNode.children.find((b) => b.text === year);
              if (!yearNode) {
                  yearNode = createNewBullet(year);
                  journalNode.children.push(yearNode);
              }
              let monthNode = yearNode.children.find((b) => b.text === month);
              if (!monthNode) {
                  monthNode = createNewBullet(month);
                  yearNode.children.push(monthNode);
              }
              let dayNode = monthNode.children.find((b) => b.text === dayText);
              if (!dayNode) {
                  dayNode = createNewBullet(dayText);
                  monthNode.children.push(dayNode);
              }
              setBullets(newBullets);
              handleNavigate(dayNode.id);
          }, [handleNavigate]);

          const handleUpdate = useCallback((id, updates) => {
              setBullets(prev => {
                  let hasChange = false;
                  const updateNode = (nodes) => {
                      return nodes.map(node => {
                          if (node.id === id) {
                              const updatedNode = { ...node, ...updates, updatedAt: Date.now() };
                              hasChange = true;
                              if (updates.text !== undefined && updates.text !== node.text) {
                                  updateRecentList(node.id, updates.text, updatedNode.updatedAt);
                              }
                              return updatedNode;
                          }
                          if (node.children.length > 0) {
                               const newChildren = updateNode(node.children);
                               if (newChildren !== node.children) return { ...node, children: newChildren };
                          }
                          return node;
                      });
                  };
                  const next = updateNode(prev);
                  return hasChange ? next : prev;
              });
          }, [updateRecentList]);

          const handleAddSibling = useCallback((id, text = '') => {
              setBullets(prev => {
                  const addSibling = (nodes) => {
                      const index = nodes.findIndex(n => n.id === id);
                      if (index !== -1) {
                          const newBullet = createNewBullet(text);
                          const newNodes = [...nodes];
                          newNodes.splice(index + 1, 0, newBullet);
                          setTimeout(() => handleFocusChange(newBullet.id, 'start', 'edit'), 0); 
                          return newNodes;
                      }
                      return nodes.map(node => {
                          if (node.children.length > 0) {
                              const newChildren = addSibling(node.children);
                              if (newChildren !== node.children) return { ...node, children: newChildren };
                          }
                          return node;
                      });
                  };
                  return addSibling(prev);
              });
          }, [handleFocusChange]);

          const handleMoveBullet = useCallback((id, direction) => {
              setBullets(prev => {
                  const move = (nodes) => {
                      const index = nodes.findIndex(n => n.id === id);
                      if (index !== -1) {
                          const newNodes = [...nodes];
                          if (direction === 'up' && index > 0) {
                              [newNodes[index], newNodes[index - 1]] = [newNodes[index - 1], newNodes[index]];
                          } else if (direction === 'down' && index < nodes.length - 1) {
                              [newNodes[index], newNodes[index + 1]] = [newNodes[index + 1], newNodes[index]];
                          }
                          return newNodes;
                      }
                      return nodes.map(node => ({ ...node, children: move(node.children) }));
                  };
                  return move(prev);
              });
          }, []);

          const handleIndent = useCallback((id) => {
              setBullets(prev => {
                  const indent = (nodes) => {
                      const index = nodes.findIndex(n => n.id === id);
                      if (index > 0) {
                          const prevSibling = nodes[index - 1];
                          const nodeToMove = nodes[index];
                          const newPrevSibling = {
                              ...prevSibling,
                              children: [...prevSibling.children, nodeToMove],
                              isCollapsed: false 
                          };
                          const newNodes = [...nodes];
                          newNodes.splice(index - 1, 2, newPrevSibling);
                          return newNodes;
                      }
                      return nodes.map(n => ({ ...n, children: indent(n.children) }));
                  };
                  return indent(prev);
              });
          }, []);

          const handleOutdent = useCallback((id) => {
              setBullets(prev => {
                   const process = (nodes) => {
                       for(let i = 0; i < nodes.length; i++) {
                           const node = nodes[i];
                           if (node.children.some(c => c.id === id)) {
                               const childIndex = node.children.findIndex(c => c.id === id);
                               const child = node.children[childIndex];
                               const newChildren = [...node.children];
                               newChildren.splice(childIndex, 1);
                               const newParent = { ...node, children: newChildren };
                               const pulled = child;
                               const newNodes = [...nodes];
                               newNodes[i] = newParent;
                               newNodes.splice(i + 1, 0, pulled);
                               return { nodes: newNodes, pulled: null }; 
                           }
                           const result = process(node.children);
                           if (result.nodes !== node.children) {
                               const newNodes = [...nodes];
                               newNodes[i] = { ...node, children: result.nodes };
                               return { nodes: newNodes, pulled: null };
                           }
                       }
                       return { nodes, pulled: null };
                   };
                   return process(prev).nodes;
              });
          }, []);

          const handleMerge = useCallback((id) => {
              setBullets(prev => {
                  const merge = (nodes) => {
                      const index = nodes.findIndex(n => n.id === id);
                      if (index > 0) {
                          const prevSibling = nodes[index - 1];
                          const nodeToMerge = nodes[index];
                          const mergedText = prevSibling.text + nodeToMerge.text;
                          const newPrevSibling = {
                              ...prevSibling,
                              text: mergedText,
                              children: [...prevSibling.children, ...nodeToMerge.children]
                          };
                          const newNodes = [...nodes];
                          newNodes.splice(index - 1, 2, newPrevSibling);
                          setTimeout(() => handleFocusChange(prevSibling.id, prevSibling.text.length, 'edit'), 0);
                          return newNodes;
                      }
                      return nodes.map(n => ({ ...n, children: merge(n.children) }));
                  };
                  return merge(prev);
              });
          }, [handleFocusChange]);

          const handleDelete = useCallback((id) => {
              const visibleIds = visibleBulletIdsRef.current;
              const currentIndex = visibleIds.indexOf(id);
              let nextFocusId = null;
              if (currentIndex > 0) nextFocusId = visibleIds[currentIndex - 1];
              else if (currentIndex < visibleIds.length - 1) nextFocusId = visibleIds[currentIndex + 1];
              setBullets(prev => {
                   const deleteNode = (nodes) => nodes.filter(n => n.id !== id).map(n => ({ ...n, children: deleteNode(n.children) }));
                   return deleteNode(prev);
              });
              if (nextFocusId) handleFocusChange(nextFocusId, 'end', 'edit');
              else handleFocusChange(null);
              removeFromRecentList(id);
          }, [handleFocusChange, removeFromRecentList]);

          const handleFocusMove = useCallback((direction, position, mode) => {
              const visibleIds = visibleBulletIdsRef.current;
              if (!visibleIds.length) return;
              const currentId = focusOptionsRef.current.id;
              const currentIndex = currentId ? visibleIds.indexOf(currentId) : -1;
              let nextIndex;
              if (currentIndex === -1) nextIndex = 0;
              else if (direction === 'up') nextIndex = currentIndex > 0 ? currentIndex - 1 : currentIndex;
              else nextIndex = currentIndex < visibleIds.length - 1 ? currentIndex + 1 : currentIndex;
              const nextId = visibleIds[nextIndex];
              if (nextId) handleFocusChange(nextId, position, mode || focusOptionsRef.current.mode);
          }, [handleFocusChange]);

          const handleFocusParent = useCallback((id) => {
              const findParent = (nodes, parentId) => {
                  for(const node of nodes) {
                      if (node.id === id) return parentId;
                      const found = findParent(node.children, node.id);
                      if (found) return found;
                  }
                  return null;
              };
              const parentId = findParent(bullets, null);
              if (parentId && parentId !== zoomedBulletId) handleFocusChange(parentId, undefined, 'view');
          }, [bullets, zoomedBulletId, handleFocusChange]);

          const handleFocusChild = useCallback((id) => {
              const findNode = (nodes) => {
                   for(const node of nodes) {
                       if(node.id === id) return node;
                       const found = findNode(node.children);
                       if(found) return found;
                   }
                   return null;
              };
              const node = findNode(bullets);
              if (node && node.children.length > 0) handleFocusChange(node.children[0].id, undefined, 'view');
          }, [bullets, handleFocusChange]);

          const handleFold = useCallback((id, collapse) => {
              setBullets(prev => {
                  const fold = (nodes) => {
                      return nodes.map(n => {
                          if (n.id === id) return { ...n, isCollapsed: collapse };
                          if (n.children.length > 0) return { ...n, children: fold(n.children) };
                          return n;
                      });
                  };
                  return fold(prev);
              });
          }, []);

          const handleFoldAll = useCallback((id, collapse) => {
              setBullets(prev => {
                   const setCollapseRecursively = (nodes) => nodes.map(node => { 
                      const newNode = { ...node }; 
                      if (newNode.children.length > 0) { 
                          newNode.isCollapsed = collapse; 
                          if (!newNode.isReadOnly) newNode.children = setCollapseRecursively(newNode.children); 
                      } 
                      return newNode; 
                  });
                  const findAndFold = (nodes) => {
                      return nodes.map(n => {
                          if (n.id === id) {
                               const updatedNode = { ...n };
                               if (updatedNode.children.length > 0) {
                                   updatedNode.isCollapsed = collapse;
                                   updatedNode.children = setCollapseRecursively(updatedNode.children);
                               }
                               return updatedNode;
                          }
                          if (n.children.length > 0) return { ...n, children: findAndFold(n.children) };
                          return n;
                      });
                  };
                  return findAndFold(prev);
              });
          }, []);

          const handleTriggerLinkPopup = useCallback((bulletId, query, inputRef, handler) => {
              const rect = inputRef.current?.getBoundingClientRect();
              if (rect) {
                  setLinkPopupState({
                      isOpen: true, targetId: bulletId, query, position: { top: rect.bottom + window.scrollY, left: rect.left + window.scrollX }, suggestions: [], selectedIndex: 0
                  });
                  setLinkSelectionHandler({ handler });
              }
          }, []);

          const handleCloseLinkPopup = useCallback(() => {
              setLinkPopupState(prev => ({ ...prev, isOpen: false }));
              setLinkSelectionHandler({ handler: null });
          }, []);

          const handleTriggerTagPopup = useCallback((bulletId, query, inputRef, handler) => {
              const rect = inputRef.current?.getBoundingClientRect();
              if (rect) {
                   setTagPopupState({
                      isOpen: true, targetId: bulletId, query, position: { top: rect.bottom + window.scrollY, left: rect.left + window.scrollX }, suggestions: [], selectedIndex: 0
                  });
                  setTagSelectionHandler({ handler });
              }
          }, []);
          
          const handleCloseTagPopup = useCallback(() => {
              setTagPopupState(prev => ({ ...prev, isOpen: false }));
              setTagSelectionHandler({ handler: null });
          }, []);
          
          const linkSuggestions = useMemo(() => {
              if (!linkPopupState.isOpen || !linkPopupState.query) return [];
              const flat = [];
              const traverse = (nodes, path) => {
                  for(const n of nodes) {
                      flat.push({ id: n.id, text: n.text, path });
                      traverse(n.children, [...path, n.text]);
                  }
              };
              traverse(bullets, []);
              return flat.filter(b => b.text.toLowerCase().includes(linkPopupState.query.toLowerCase())).slice(0, 50);
          }, [bullets, linkPopupState.isOpen, linkPopupState.query]);
          
          const tagSuggestions = useMemo(() => {
              if (!tagPopupState.isOpen) return [];
              const tags = new Set();
              const traverse = (nodes) => {
                  for(const n of nodes) {
                      const matches = n.text.match(/#\w+/g);
                      if (matches) matches.forEach(t => tags.add(t));
                      traverse(n.children);
                  }
              };
              traverse(bullets);
              return Array.from(tags).filter(t => t.toLowerCase().includes(tagPopupState.query.toLowerCase())).sort().slice(0, 50);
          }, [bullets, tagPopupState.isOpen, tagPopupState.query]);

          const handleLinkNavigate = useCallback((direction) => {
              setLinkPopupState(prev => ({ ...prev, selectedIndex: navigateSuggestions({ suggestions: linkSuggestions, selectedIndex: prev.selectedIndex }, direction) }));
          }, [linkSuggestions]);

           const handleTagNavigate = useCallback((direction) => {
              setTagPopupState(prev => ({ ...prev, selectedIndex: navigateSuggestions({ suggestions: tagSuggestions, selectedIndex: prev.selectedIndex }, direction) }));
          }, [tagSuggestions]);

          const handleLinkSelect = useCallback((callback) => {
              if (linkSuggestions[linkPopupState.selectedIndex]) callback(linkSuggestions[linkPopupState.selectedIndex]);
          }, [linkSuggestions, linkPopupState.selectedIndex]);

          const handleTagSelect = useCallback((callback) => {
              if (tagSuggestions[tagPopupState.selectedIndex]) callback(tagSuggestions[tagPopupState.selectedIndex]);
          }, [tagSuggestions, tagPopupState.selectedIndex]);


          const handleExport = () => {
              const dataStr = JSON.stringify(bullets, null, 2);
              const blob = new Blob([dataStr], { type: "application/json" });
              const url = URL.createObjectURL(blob);
              const link = document.createElement("a");
              link.href = url;
              link.download = `${settings.fileName || 'outline'}.json`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
          };

          const handleImportFile = (data) => {
              setPendingImportData(regenerateIds(migrateBullets(data)));
              setIsImportModalOpen(true);
          };

          const handleConfirmImport = (targetId) => {
              if (pendingImportData) {
                  setBullets(prev => {
                      if (targetId === null) return [...prev, ...pendingImportData];
                      const addToTarget = (nodes) => {
                          return nodes.map(n => {
                              if (n.id === targetId) return { ...n, children: [...n.children, ...pendingImportData] };
                              return { ...n, children: addToTarget(n.children) };
                          });
                      };
                      return addToTarget(prev);
                  });
                  addToast(`Imported ${pendingImportData.length} items`, 'success');
              }
              setIsImportModalOpen(false);
              setPendingImportData(null);
          };

          const handleClearData = () => {
              if (confirm("Are you sure you want to delete all data? This cannot be undone.")) {
                  setBullets(initialData);
                  setRecentBullets([]);
                  setFavoriteBullets([]);
                  addToast('Application data reset', 'info');
                  setIsSettingsModalOpen(false);
              }
          };


          useEffect(() => {
              const handleGlobalKeyDown = (e) => {
                  if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'k') {
                      e.preventDefault();
                      setIsSearchModalOpen(true);
                  } else if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'h') {
                      e.preventDefault();
                      handleZoom(null);
                      setBullets(prev => prev.map(b => ({ ...b, isCollapsed: true })));
                      setTimeout(() => {
                          const currentBullets = bulletsRef.current;
                          if (currentBullets.length > 0) handleFocusChange(currentBullets[0].id, 'start', 'view');
                      }, 10);
                  } else if (e.ctrlKey && e.key.toLowerCase() === 'j') {
                      e.preventDefault();
                      handleGoToJournal();
                  } else if (e.ctrlKey && e.key === 'ArrowUp') {
                       e.preventDefault();
                       const zoomedId = zoomedBulletIdRef.current;
                       const crumbs = breadcrumbsRef.current;
                       if (zoomedId) {
                           const parentId = crumbs.length > 1 ? crumbs[crumbs.length - 2].id : null;
                           handleZoom(parentId);
                       }
                  } else if ((e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
                      const currentFocusId = focusOptionsRef.current.id;
                      const visibleIds = visibleBulletIdsRef.current;
                      if (!currentFocusId && visibleIds.length > 0) {
                           const target = e.target;
                           if(target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA') {
                               e.preventDefault();
                               handleFocusChange(visibleIds[0], 'end', 'view');
                           }
                      }
                  }
              };
              window.addEventListener('keydown', handleGlobalKeyDown);
              return () => { window.removeEventListener('keydown', handleGlobalKeyDown); };
          }, [handleGoToJournal, handleZoom, handleFocusChange]);


          return (
              <div className="flex flex-col h-screen bg-white dark:bg-gray-900 text-[var(--main-color)] font-[family-name:var(--font-family)] overflow-hidden transition-colors duration-200">
                  <div className="flex-grow flex overflow-hidden">
                      <LeftSidebar 
                          isOpen={isSidebarOpen} 
                          recents={recentBullets} 
                          favorites={favoriteBullets} 
                          onNavigate={handleNavigate} 
                      />
                      
                      <div className="flex-grow flex flex-col h-full overflow-hidden relative">
                          <Toolbar
                              onImport={handleImportFile}
                              onExport={handleExport}
                              breadcrumbs={breadcrumbs}
                              onBreadcrumbClick={handleZoom}
                              fileName={settings.fileName}
                              onOpenSettings={() => setIsSettingsModalOpen(true)}
                              onGoToToday={handleGoToJournal}
                              theme={theme}
                              onThemeToggle={handleThemeToggle}
                              onOpenSearch={() => setIsSearchModalOpen(true)}
                              isSidebarOpen={isSidebarOpen}
                              onToggleSidebar={() => {
                                  setIsSidebarOpen(prev => {
                                      db.keyValuePairs.put({ key: 'isSidebarOpen', value: !prev });
                                      return !prev;
                                  });
                              }}
                              isFavorite={isTargetFavorite}
                              onToggleFavorite={handleToggleFavorite}
                              canFavorite={!!targetFavoriteId}
                          />

                          <div className="flex-grow overflow-y-auto p-4 sm:p-8" onClick={() => handleFocusChange(null)}>
                              <div className="max-w-4xl mx-auto pb-40">
                                   {displayedBullets.length === 0 ? (
                                      <div className="text-gray-400 dark:text-gray-500 italic mt-8 text-center cursor-pointer" onClick={(e) => {
                                          e.stopPropagation();
                                          const newBullet = createNewBullet();
                                          setBullets(prev => {
                                              if (zoomedBulletId) {
                                                   return prev.map(n => n.id === zoomedBulletId ? { ...n, children: [newBullet] } : n); 
                                              }
                                              return [...prev, newBullet];
                                          });
                                          setTimeout(() => handleFocusChange(newBullet.id, 'start', 'edit'), 0);
                                      }}>
                                          Click to add a bullet
                                      </div>
                                   ) : (
                                       displayedBullets.map(bullet => (
                                          <BulletItem
                                              key={bullet.id}
                                              bullet={bullet}
                                              level={0}
                                              onUpdate={handleUpdate}
                                              onAddSibling={handleAddSibling}
                                              onDelete={handleDelete}
                                              onIndent={handleIndent}
                                              onOutdent={handleOutdent}
                                              onFocusChange={handleFocusChange}
                                              onZoom={handleZoom}
                                              onFocusMove={handleFocusMove}
                                              onFocusParent={handleFocusParent}
                                              onFocusChild={handleFocusChild}
                                              onFold={handleFold}
                                              onFoldAll={handleFoldAll}
                                              onMoveBullet={handleMoveBullet}
                                              currentFocusId={currentFocusId}
                                              focusPosition={focusPosition}
                                              focusMode={focusMode}
                                              searchQuery={searchQuery}
                                              onLinkClick={(text) => {
                                                   setSearchQuery(text); 
                                                   setIsSearchModalOpen(true);
                                              }}
                                              onTriggerLinkPopup={handleTriggerLinkPopup}
                                              onCloseLinkPopup={handleCloseLinkPopup}
                                              onLinkNavigate={handleLinkNavigate}
                                              onLinkSelect={handleLinkSelect}
                                              isLinkPopupOpen={linkPopupState.isOpen}
                                              linkPopupTargetId={linkPopupState.targetId}
                                              onTriggerTagPopup={handleTriggerTagPopup}
                                              onCloseTagPopup={handleCloseTagPopup}
                                              onTagNavigate={handleTagNavigate}
                                              onTagSelect={handleTagSelect}
                                              isTagPopupOpen={tagPopupState.isOpen}
                                              tagPopupTargetId={tagPopupState.targetId}
                                              isJournalRoot={bullet.text === DAILY_LOG_ROOT_TEXT}
                                              onNavigateTo={handleNavigate}
                                              onMerge={handleMerge}
                                          />
                                       ))
                                   )}
                              </div>
                          </div>

                          <SearchModal 
                              isOpen={isSearchModalOpen} 
                              onClose={() => {
                                  setIsSearchModalOpen(false);
                                  setSearchQuery('');
                              }} 
                              bullets={bullets} 
                              onNavigate={handleNavigate}
                              initialQuery={searchQuery}
                          />

                          <SettingsModal
                              isOpen={isSettingsModalOpen}
                              onClose={() => setIsSettingsModalOpen(false)}
                              onSave={setSettings}
                              currentSettings={settings}
                              onClearData={handleClearData}
                          />

                          <ImportSelectionModal
                              isOpen={isImportModalOpen}
                              onClose={() => { setIsImportModalOpen(false); setPendingImportData(null); }}
                              onConfirm={handleConfirmImport}
                              bullets={bullets}
                          />

                          <ToastContainer toasts={toasts} removeToast={removeToast} />
                          
                          {linkPopupState.isOpen && (
                              <LinkPopup
                                  suggestions={linkSuggestions}
                                  selectedIndex={linkPopupState.selectedIndex}
                                  onSelect={(b) => linkSelectionHandler.handler && linkSelectionHandler.handler(b)}
                                  position={linkPopupState.position}
                                  containerRef={linkPopupRef}
                              />
                          )}

                          {tagPopupState.isOpen && (
                              <TagPopup
                                  suggestions={tagSuggestions}
                                  selectedIndex={tagPopupState.selectedIndex}
                                  onSelect={(t) => tagSelectionHandler.handler && tagSelectionHandler.handler(t)}
                                  position={tagPopupState.position}
                                  containerRef={tagPopupRef}
                              />
                          )}
                      </div>
                  </div>
                  <footer className="flex-shrink-0 p-1 px-4 text-sm text-[var(--main-color)] border-t border-gray-200 dark:border-gray-700 bg-white/80 dark:bg-gray-800/80 backdrop-blur-sm flex justify-between items-center z-10 w-full">
                        <div className="flex items-center gap-2 min-w-0">
                            <span title={settings.fileName} className="truncate">{settings.fileName}</span>
                        </div>
                        <a 
                            href="https://github.com/jaroet/JaRoet-Outliner/releases" 
                            target="_blank" 
                            rel="noopener noreferrer" 
                            className="flex-shrink-0 ml-2 hover:underline"
                            title="View Release Notes"
                        >
                            Version 0.1.34
                        </a>
                  </footer>
              </div>
          );
      };

      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }

      const root = createRoot(rootElement);
      root.render(
          <App />
      );
    </script>
  </body>
</html>
